<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cpp算法-BFS</title>
    <url>/p/99890668.html</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文实现只是框架，应当灵活运用，bfs()函数内部根据情况灵活更改<br>广搜算法基于树、队列实现，具体思路: <code>将当前点的子节点入队，当前点出队，如果子节点满足条件则记录</code>并重复此过程</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    vis[start_x][start_y] = <span class="literal">true</span>;            <span class="comment">//标记起始点</span></span><br><span class="line">    que[head][<span class="number">0</span>] = start_x; </span><br><span class="line">    que[head][<span class="number">1</span>] = start_y;                  <span class="comment">//起始点入队</span></span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail)                       <span class="comment">//队不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que[head][<span class="number">0</span>], y = que[head][<span class="number">1</span>]  <span class="comment">//获取队首点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; 子节点数; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = x子节点, y2 = y子节点;</span><br><span class="line">            <span class="keyword">if</span> (x2, y2满足条件 &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                记录结果;</span><br><span class="line">                vis[x2][y2] = <span class="literal">true</span>;</span><br><span class="line">                que[tail][<span class="number">0</span>] = x2;</span><br><span class="line">                que[tail][<span class="number">0</span>] = y2;</span><br><span class="line">                tail++;                         <span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head++;                                 <span class="comment">//队首出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="STL-queue"><a href="#STL-queue" class="headerlink" title="STL-queue"></a>STL-queue</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;node, top;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    node.x = sx;</span><br><span class="line">    node.y = sy;</span><br><span class="line">    que.push(node);</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        top = que.front();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = ..., y2 = ...;</span><br><span class="line">            <span class="keyword">if</span> (x2, y2满足条件 &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                记录结果;</span><br><span class="line">                vis[x2][y2] = <span class="literal">true</span>;</span><br><span class="line">                node.x = x2;</span><br><span class="line">                node.y = y2;</span><br><span class="line">                que.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><a href="https://www.luogu.org/problemnew/show/P1443" target="_blank" rel="noopener">洛谷P1443</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy, vis[<span class="number">210</span>][<span class="number">210</span>], ans[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> gox[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> goy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">horse</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;node, top;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;horse&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    node.x = sx;</span><br><span class="line">    node.y = sy;</span><br><span class="line">    que.push(node);</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        top = que.front();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = top.x + gox[i];</span><br><span class="line">            <span class="keyword">int</span> y2 = top.y + goy[i];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt;= <span class="number">1</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= <span class="number">1</span> &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[x2][y2] = ans[top.x][top.y] + <span class="number">1</span>;</span><br><span class="line">                vis[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                node.x = x2;</span><br><span class="line">                node.y = y2;</span><br><span class="line">                que.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;sx, &amp;sy);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%-5d"</span>, ans[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy, vis[<span class="number">210</span>][<span class="number">210</span>], que[<span class="number">50000</span>][<span class="number">2</span>], ans[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> gox[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> goy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    que[head][<span class="number">0</span>] = sx;</span><br><span class="line">    que[head][<span class="number">1</span>] = sy;</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, x2, y, y2;</span><br><span class="line">        x = que[head][<span class="number">0</span>];</span><br><span class="line">        y = que[head][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x2 = x + gox[i];</span><br><span class="line">            y2 = y + goy[i];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt;= <span class="number">1</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= <span class="number">1</span> &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[x2][y2] = ans[x][y] + <span class="number">1</span>;</span><br><span class="line">                vis[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                que[tail][<span class="number">0</span>] = x2;</span><br><span class="line">                que[tail][<span class="number">1</span>] = y2;</span><br><span class="line">                tail++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;sx, &amp;sy);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%-5d"</span>, ans[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-DFS</title>
    <url>/p/9d047ada.html</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文实现只是框架，应当灵活运用，dfs(…)函数返回值类型、参数列表根据情况灵活更改</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数列表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (到达目的地) 输出结果;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; 行动方法数; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (下一步可行)</span><br><span class="line">            &#123;</span><br><span class="line">                记录此步;</span><br><span class="line">                dfs(改动后的参数列表);</span><br><span class="line">                取消记录此步;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><a href="https://www.luogu.org/problemnew/show/P1605" target="_blank" rel="noopener">洛谷P1605</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, sx, sy, fx, fy, ans;</span><br><span class="line"><span class="keyword">int</span> mg[<span class="number">6</span>][<span class="number">6</span>], now[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x2, y2;</span><br><span class="line">    <span class="keyword">if</span> (x == fx &amp;&amp; y == fy) ans++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x2 = x + go[i][<span class="number">0</span>];</span><br><span class="line">            y2 = y + go[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt; <span class="number">0</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt; <span class="number">0</span> &amp;&amp; y2 &lt;= m &amp;&amp; mg[x2][y2] == <span class="number">0</span> &amp;&amp; now[x2][y2] == <span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">            &#123;</span><br><span class="line">                now[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                dfs(x2, y2);</span><br><span class="line">                now[x2][y2] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mg, <span class="number">0</span>, <span class="keyword">sizeof</span>(mg));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;sx, &amp;sy, &amp;fx, &amp;fy);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        mg[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    now[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    dfs(sx, sy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-STL标准库</title>
    <url>/p/ac108281.html</url>
    <content><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写函数/结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T x, y;</span><br><span class="line">    Point(T x = <span class="number">0</span>, T y = <span class="number">0</span>):x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Point&lt;T&gt; <span class="keyword">operator</span> + (<span class="keyword">const</span> Point&lt;T&gt;&amp; A, <span class="keyword">const</span> Point&lt;T&gt;&amp; B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Point&lt;T&gt;(A.x + B.x, A.y + B.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Point&lt;T&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">"("</span> &lt;&lt; p.x &lt;&lt; <span class="string">","</span> &lt;&lt; p.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vector-不定长数组"><a href="#vector-不定长数组" class="headerlink" title="vector(不定长数组)"></a>vector(不定长数组)</h2><hr>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><code>vector&lt;数据类型&gt; 名;</code> 例 <code>vector&lt;int&gt; a;</code></p>
<h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p><code>a.size();</code>读取大小<br><br><code>a.resize();</code>改变大小<br><br><code>a.push_back(x);</code>尾部添加元素x<br><br><code>a.pop_back();</code>删除最后一个元素<br><br><code>a.clear();</code>清空<br><br><code>a.empty()</code>询问是否为空(bool类型)<br><br><code>a[]</code>访问元素(可修改)<br></p>
<h2 id="priority-queue-优先队列-堆"><a href="#priority-queue-优先队列-堆" class="headerlink" title="priority_queue(优先队列/堆)"></a>priority_queue(优先队列/堆)</h2><hr>
<h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p><strong>头文件</strong>: <code>#include &lt;queue&gt;</code><br><br><strong>参数</strong>: <code>priority_queue&lt;Type, Container, Functional&gt;</code><br><br>&emsp;<code>Type</code>数据类型 <em>不可省</em><br><br>&emsp;<code>Container</code>容器(vector,deque)默认vector<br><br>&emsp;<code>Functional</code>比较方式,默认<code>operator &lt;</code>大根堆</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>与queue类似<br></p>
<h4 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h4><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code>使用仿函数<code>greater&lt;&gt;</code><br></p>
<h4 id="自定义类型-struct"><a href="#自定义类型-struct" class="headerlink" title="自定义类型(struct)"></a>自定义类型(struct)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>):x(a), y(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="重载operator-lt"><a href="#重载operator-lt" class="headerlink" title="重载operator &lt;"></a>重载operator &lt;</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br></pre></td></tr></table></figure>
<p>x值大的优先级低,排在队前<br><br>x相等,y大的优先级低</p>
<h5 id="重写仿函数"><a href="#重写仿函数" class="headerlink" title="重写仿函数"></a>重写仿函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-动态规划</title>
    <url>/p/8364d7e9.html</url>
    <content><![CDATA[<p><strong><em>待完成</em></strong></p>
<h2 id="多阶段过程决策的最优化问题"><a href="#多阶段过程决策的最优化问题" class="headerlink" title="多阶段过程决策的最优化问题"></a>多阶段过程决策的最优化问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A --5--&gt; B1</span><br><span class="line">    A --3--&gt; B2</span><br><span class="line">    B1 --1--&gt; C1</span><br><span class="line">    B1 --6--&gt; C2</span><br><span class="line">    B1 --3--&gt; C3</span><br><span class="line">    B2 --8--&gt; C2</span><br><span class="line">    B2 --4--&gt; C4</span><br><span class="line">    C1 --5--&gt; D1</span><br><span class="line">    C1 --6--&gt; D2</span><br><span class="line">    C2 --5--&gt; D1</span><br><span class="line">    C3 --8--&gt; D3</span><br><span class="line">    C4 --3--&gt; D3</span><br><span class="line">    D1 --3--&gt; E</span><br><span class="line">    D2 --4--&gt; E</span><br><span class="line">    D3 --3--&gt; E</span><br></pre></td></tr></table></figure>
<p>!!! tldr “题目及注解”<br>    求上图从 $A$ 到 $E$ 的最短距离<br><br><br>    $K$: 阶段<br><br>    $D(X_I, (X+1)_J)$: 从 $X_I$ 到 $(X+1)_J$ 的距离<br><br>    $F_K(X_I)$: $K$ 阶段下 $X_I$ 到终点 $E$ 的最短距离</p>
<p>倒推:<br>$$<br>K=4\qquad F_4(D_1)=3\qquad F_4(D_2)=4\qquad F_4(D_3)=3<br>$$<br>$$<br>K=5\qquad F_3(C_1)=min(D(C_1,D_1)+F_4(D_1),D(C_1,D_2)+F_4(D_2))=min(5+3,6+4)=8<br>F_3(C_2)<br>$$</p>
]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Dijkstra</title>
    <url>/p/982e7a01.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m</code>点数、边数<br><br><code>G[][]</code>邻接矩阵存图<br><br><code>dist[]</code>路径长度<br><br><code>pre[]</code>路径<br><br><code>make()</code>建图</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, G[maxn][maxn], dist[maxn], pre[maxn], s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            G[i][j] = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        G[from][to] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, min;</span><br><span class="line">    <span class="keyword">bool</span> p[maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != s)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i] = G[s][i];</span><br><span class="line">            pre[i]  = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s] = <span class="number">0</span>; p[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        min = INT_MAX; k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p[j] &amp;&amp; dist[j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        p[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p[j] &amp;&amp; G[k][j] != INT_MAX &amp;&amp; dist[j] &gt; dist[k] + G[k][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[k] + G[k][j];</span><br><span class="line">                pre[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆优化-链式前向星"><a href="#堆优化-链式前向星" class="headerlink" title="堆优化(链式前向星)"></a>堆优化(链式前向星)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, t;</span><br><span class="line">&#125;edge[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].to  = b;</span><br><span class="line">    edge[cnt].nxt = head[a];</span><br><span class="line">    edge[cnt].t   = t;</span><br><span class="line">    head[a]       = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> heap&amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;heap&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dist[i] = INF;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push((heap)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        heap top = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> tx = top.u;</span><br><span class="line">        <span class="keyword">int</span> td = top.d;</span><br><span class="line">        <span class="keyword">if</span> (td != dist[tx]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[tx]; i; i = edge[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[tx] + edge[i].t)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[tx] + edge[i].t;</span><br><span class="line">                dy[v] = i; </span><br><span class="line">                dx[v] = tx;    <span class="comment">//记录路径</span></span><br><span class="line">                q.push((heap)&#123;v, dist[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q = n, p[maxm];</span><br><span class="line"><span class="keyword">while</span> (q != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p[++tot] = dy[q];</span><br><span class="line">    q = dx[q];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Kruskal</title>
    <url>/p/c4fb1928.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>ufs[], find(int), unionn(int, int)</code>并查集结构<br><br><code>edge[]</code>链式前向星<br><br><code>cmp(Edge, Edge)</code>边排序方案</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ufs[x] != x) <span class="keyword">return</span> ufs[x] = find(ufs[x]);</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = find(x);</span><br><span class="line">    <span class="keyword">int</span> b = find(y);</span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> select;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.w != b.w) <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    <span class="keyword">if</span> (a.a != b.a) <span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">    <span class="keyword">return</span> a.b &lt; b.b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, x, y;</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        x = find(edge[i].a);</span><br><span class="line">        y = find(edge[i].b);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            unionn(x, y);</span><br><span class="line">            k++;</span><br><span class="line">            edge[i].select = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Floyd</title>
    <url>/p/ba77762f.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, G[][]</code>点数、边数、邻接矩阵<br><br><code>dist[][]</code>每对顶点间路径长度<br><br><code>pre[][]</code>每对顶点之间路径<br><br><code>make()</code>建图</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, G[maxn][maxn], dist[maxn][maxn], pre[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            G[i][j] = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        G[from][to] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i][j] = G[i][j];</span><br><span class="line">            pre[i][j]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                    pre[i][j]  = pre[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Prim</title>
    <url>/p/8760af74.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, _map[][]</code>点数、边数、邻接矩阵<br><br><code>dist[]</code>树根到各点路径长<br><br><code>pre[]</code>生成树路径 </p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dist[maxn], _map[maxn][maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">			_map[i][j] = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) _map[i][i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> from, to, w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">		_map[from][to] = w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">bool</span> p[maxn];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] = <span class="literal">false</span>;</span><br><span class="line">		dist[i] = _map[<span class="number">1</span>][i];</span><br><span class="line">		pre[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INT_MAX;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p[j] &amp;&amp; dist[j] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = dist[j]</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		p[k] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p[j] &amp;&amp; _map[k][j] != INT_MAX &amp;&amp; dist[j] &gt; _map[k][j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = _map[k][j];</span><br><span class="line">				pre[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-SPFA</title>
    <url>/p/8ed8c69a.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, s</code>点数、边数、源点<br><br><code>cnt, head[], edge[], add(int, int, int)</code>链式前向星<br><br><code>dist[]</code>各点到源点路径长<br><br><code>vis[]</code>记录</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, dist[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, dis;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next = head[from];</span><br><span class="line">    edge[cnt].to     = to;</span><br><span class="line">    edge[cnt].dis    = dis;</span><br><span class="line">    head[from]       = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    q.push(s);</span><br><span class="line">    dist[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop(); vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[u] + edge[i].dis)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-欧拉回路</title>
    <url>/p/57662471.html</url>
    <content><![CDATA[<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>G[][]</code>邻接矩阵<br><br><code>deg[]</code>度<br><br><code>ans[]</code>欧拉回路<br><br><code>n, e</code>点数、边数</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> G[maxn][maxn], deg[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">int</span> n, e, x, y, ansi, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G[i][j])</span><br><span class="line">		&#123;</span><br><span class="line">			G[i][j] = G[j][i] = <span class="number">0</span>;</span><br><span class="line">			Euler(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[++ansi] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;e);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">		G[x][y] = G[y][x] = <span class="number">1</span>;</span><br><span class="line">		deg[x]++;</span><br><span class="line">		deg[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">	s = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (deg[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">			s = i;</span><br><span class="line">	Euler(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ansi; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p><code>n, m</code>点数、边数<br><br><code>head, edge[]</code>链式前向星<br><br><code>ans[], ansi</code>路径、数组大小<br><br><code>vis[]</code>记录<br><br><code>make()</code>建图</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;i, &amp;j);</span><br><span class="line">		edge[k].to = i;</span><br><span class="line">		edge[k].next = head[i];</span><br><span class="line">		head[i] = k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxm];</span><br><span class="line"><span class="keyword">int</span> ansi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2</span> * maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">0</span>; k = edge[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[k])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[k] = <span class="literal">true</span>;</span><br><span class="line">            vis[k ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            dfs(edge[k].to);</span><br><span class="line">            ans[ansi++] = k;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-链式前向星</title>
    <url>/p/dda660a4.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>cnt</code>记数<br><br><code>head[]</code>记录边的头<br><br><code>struct Edge{int, int, int}</code>边信息: 开始点、结束点、权值<br><br><code>add_edge(int, int, int)</code>添加边</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt, head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to, val;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++cnt].next = head[from];</span><br><span class="line">	edge[cnt].to     = to;</span><br><span class="line">	edge[cnt].val    = val;</span><br><span class="line">	head[from]       = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-KMP</title>
    <url>/p/632c6631.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P3375" target="_blank" rel="noopener">洛谷P3375</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>pre()</code>求前缀数组<br><br><code>kmp()</code>匹配字符串<br></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">1000010</span>], s2[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000010</span>], l1, l2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s2[j + <span class="number">1</span>] != s2[i + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s2[i + <span class="number">1</span>]) j++;</span><br><span class="line">        nxt[i + <span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s2[j + <span class="number">1</span>] != s1[i + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s1[i + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - l2 + <span class="number">2</span>);</span><br><span class="line">            j = nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s2 + <span class="number">1</span>;</span><br><span class="line">    l1 = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">    l2 = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line">    pre();</span><br><span class="line">    kmp();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-哈希表</title>
    <url>/p/666f05c6.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P4305" target="_blank" rel="noopener">洛谷P4305</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>hash[]</code>哈希表<br><br><code>find(int x)</code>查找哈希表中 $x$ 的位置<br><br><code>push(int x)</code>将 $x$ 插入到哈希表中<br><br><code>check(int x)</code>查找 $x$ 是否在哈希表中</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 100003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hash(a) a%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[p], t, n, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) y = hash(-x);</span><br><span class="line">    <span class="keyword">else</span> y = hash(x);</span><br><span class="line">    <span class="keyword">while</span> (h[y] &amp;&amp; h[y] != x) y = hash(++y);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[find(x)] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[find(x)] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (!check(x))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">                push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-堆</title>
    <url>/p/bb233fbc.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>heap[]</code>堆<br><br><code>heap_size</code>堆大小<br><br><code>put(int)</code>压入一个数<br><br><code>get()</code>弹出堆顶</p>
<h4 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[maxn];</span><br><span class="line"><span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now, next;</span><br><span class="line">    heap[++heap_size] = d;</span><br><span class="line">    now = heap_size;</span><br><span class="line">    <span class="keyword">while</span> (now &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next = now &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (heap[now] &lt;= heap[next]) <span class="keyword">break</span>;</span><br><span class="line">        swap(heap[now], heap[next]);</span><br><span class="line">        now = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now, next, res;</span><br><span class="line">    res = heap[<span class="number">1</span>];</span><br><span class="line">    heap[<span class="number">1</span>] = heap[heap_size--];</span><br><span class="line">    now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (now * <span class="number">2</span> &lt;= heap_size)</span><br><span class="line">    &#123;</span><br><span class="line">        next = now * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; heap_size &amp;&amp; heap[next + <span class="number">1</span>] &lt; heap[next]) next++;</span><br><span class="line">        <span class="keyword">if</span> (heap[now] &lt;= heap[next]) <span class="keyword">break</span>;</span><br><span class="line">        swap(heap[now], heap[next]);</span><br><span class="line">        now = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="STL实现"><a href="#STL实现" class="headerlink" title="STL实现"></a>STL实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[maxn];</span><br><span class="line"><span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[++heap_size] = d;</span><br><span class="line">    push_heap(heap + <span class="number">1</span>, heap + heap_size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//push_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pop_heap(heap + <span class="number">1</span>, heap + heap_size + <span class="number">1</span>);                   </span><br><span class="line">    <span class="comment">//pop_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); </span></span><br><span class="line">    <span class="keyword">return</span> heap[heap_size--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-大整数类</title>
    <url>/p/b995b9d7.html</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">5000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) a&gt;b ? a : b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) a&lt;b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigInteger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> len, s[maxl];</span><br><span class="line">		</span><br><span class="line">		BigInteger();</span><br><span class="line">		BigInteger(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">		BigInteger(<span class="keyword">int</span>);</span><br><span class="line">		<span class="keyword">bool</span> sign;</span><br><span class="line">		<span class="function"><span class="built_in">string</span> <span class="title">toStr</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;, BigInteger&amp;);</span><br><span class="line">		<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, BigInteger&amp;);</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>++();</span><br><span class="line">		BigInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>--();</span><br><span class="line">		BigInteger <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> num) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>/=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">factorial</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">Sqrt</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">Pow</span><span class="params">(<span class="keyword">const</span> BigInteger&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>;</span><br><span class="line">		~BigInteger;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BigInteger::BigInteger()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">	len = <span class="number">1</span>;</span><br><span class="line">	sign = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::BigInteger(<span class="keyword">const</span> <span class="keyword">char</span> *num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::BigInteger(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> BigInteger::toStr() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> res;</span><br><span class="line">	res = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">		res = (<span class="keyword">char</span>)(s[i] + <span class="string">'0'</span>) + res;</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="string">""</span>) res = <span class="string">"0"</span>;</span><br><span class="line">	<span class="keyword">if</span> (!sign &amp;&amp; res != <span class="string">"0"</span>) res = <span class="string">"-"</span> + res;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	in&gt;&gt;str;</span><br><span class="line">	num = str;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	out&lt;&lt;num.toStr();</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">	<span class="keyword">char</span> a[maxl] = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">if</span> (num[<span class="number">0</span>] != <span class="string">"-"</span>)</span><br><span class="line">		<span class="built_in">strcpy</span>(a, num);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(num); ++i)</span><br><span class="line">			a[i - <span class="number">1</span>] = num[i];</span><br><span class="line">	sign = !(num[<span class="number">0</span>] == <span class="string">"-"</span>);</span><br><span class="line">	len = <span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); ++i)</span><br><span class="line">		s[i] = a[len - i - <span class="number">1</span>] - <span class="number">48</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">		sign = <span class="number">0</span>, num = -num;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sign = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> temp[MAX_L];</span><br><span class="line">	<span class="built_in">sprintf</span>(temp, <span class="string">"%d"</span>, num);</span><br><span class="line">	*<span class="keyword">this</span> = temp;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* tmp;</span><br><span class="line">	tmp = num.c_str();</span><br><span class="line">	*<span class="keyword">this</span> = tmp;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sign^num.sign)</span><br><span class="line">		<span class="keyword">return</span> num.sign;</span><br><span class="line">	<span class="keyword">if</span> (len != num.len)</span><br><span class="line">		<span class="keyword">return</span> len &lt; num.len;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">if</span> (s[i] != num.s[i])</span><br><span class="line">			<span class="keyword">return</span> sign ? (s[i] &lt; num.s[i]) : (s[i] &gt; num.s[i])</span><br><span class="line">	<span class="keyword">return</span> !sign;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> num &lt; *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span> &gt; num || *<span class="keyword">this</span> &lt; num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(num != *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">if</span> (sign^num.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 BigInteger tmp = sign ? num : *<span class="keyword">this</span>;</span><br><span class="line">		 tmp.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> sign ? *<span class="keyword">this</span> - tmp : num - tmp;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger result;</span><br><span class="line">	 result.len = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; temp || i &lt; (max(len, num.len)); i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">int</span> t = s[i] + num.s[i] + temp;</span><br><span class="line">		 result.s[result.len++] = t % <span class="number">10</span>;</span><br><span class="line">		 temp = t / <span class="number">10</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 result.sign = sign;</span><br><span class="line">	 <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BigInteger old = *<span class="keyword">this</span>;</span><br><span class="line">	++(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> + num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 BigInteger b = num, a = *<span class="keyword">this</span>;</span><br><span class="line">	 <span class="keyword">if</span> (!num.sign &amp;&amp; !sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 b.sign = <span class="number">1</span>;</span><br><span class="line">		 a.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> b - a;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (!b.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 b.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> a + b;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (!a.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 a.sign = <span class="number">1</span>;</span><br><span class="line">		 b = BigInteger(<span class="number">0</span>) - (a + b);</span><br><span class="line">		 <span class="keyword">return</span> b;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">	 &#123;</span><br><span class="line">		 BigInteger c = (b - a);</span><br><span class="line">		 c.sign = <span class="literal">false</span>;</span><br><span class="line">		 <span class="keyword">return</span> c;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger result;</span><br><span class="line">	 result.len = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, g = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">int</span> x = a.s[i] - g;</span><br><span class="line">		 <span class="keyword">if</span> (i &lt; b.len) x -= b.s[i];</span><br><span class="line">		 <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">else</span></span><br><span class="line">		 &#123;</span><br><span class="line">			 g = <span class="number">1</span>;</span><br><span class="line">			 x += <span class="number">10</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 result.s[result.len++] = x;</span><br><span class="line">	 &#125;</span><br><span class="line">	 result.clean();</span><br><span class="line">	 <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BigInteger old = *<span class="keyword">this</span>;</span><br><span class="line">	--(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> - num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger result;</span><br><span class="line">	result.len = len + num.len;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.len; j++)</span><br><span class="line">			result.s[i + j] += s[i] * num.s[j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		 result.s[i + <span class="number">1</span>] += result.s[i] / <span class="number">10</span>;</span><br><span class="line">		 result.s[i] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	result.clean();</span><br><span class="line">	result.sign = !(sign^num.sign);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger x = num;</span><br><span class="line">	BigInteger z = *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 BigInteger ans;</span><br><span class="line">	 ans.len = len - num.len + <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">if</span> (ans.len &lt; <span class="number">0</span>)</span><br><span class="line">	 &#123;</span><br><span class="line">		 ans.len = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> ans;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger divisor = *<span class="keyword">this</span>, divid = num;</span><br><span class="line">	 divisor.sign = divid.sign = <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">int</span> k = ans.len - <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">while</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">while</span> (divisor.s[j] == <span class="number">0</span>) j--;</span><br><span class="line">		 <span class="keyword">if</span> (k &gt; j) k = j;</span><br><span class="line">		 <span class="keyword">char</span> z[MAX_L];</span><br><span class="line">		 <span class="built_in">memset</span>(z, <span class="number">0</span>, <span class="keyword">sizeof</span>(z));</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &gt;= k; i--)</span><br><span class="line">			 z[j - i] = divisor.s[i] + <span class="string">'0'</span>;</span><br><span class="line">			 BigInteger dividend = z;</span><br><span class="line">			 <span class="keyword">if</span> (dividend &lt; divid) &#123; k--; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			 <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">			 <span class="keyword">while</span> (divid*key &lt;= dividend) key++;</span><br><span class="line">			 key--;</span><br><span class="line">			 ans.s[k] = key;</span><br><span class="line">			 BigInteger temp = divid*key;</span><br><span class="line">			 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">				 temp = temp * <span class="number">10</span>;</span><br><span class="line">				 divisor = divisor - temp;</span><br><span class="line">				 k--;</span><br><span class="line">	 &#125;</span><br><span class="line">	 ans.clean();</span><br><span class="line">	 ans.sign = !(sign^num.sign);</span><br><span class="line">	 <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> / num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger a = *<span class="keyword">this</span>, b = num;</span><br><span class="line">	a.sign = b.sign = <span class="number">1</span>;</span><br><span class="line">	BigInteger result, temp = a / b*b;</span><br><span class="line">	result = a - temp;</span><br><span class="line">	result.sign = sign;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::Pow(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (BigInteger i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">		result = result * (*<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::factorial() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (BigInteger i = <span class="number">1</span>; i &lt;= *<span class="keyword">this</span>; i++)</span><br><span class="line">		result *= i;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BigInteger::clean()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) len++;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; s[len - <span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">		len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::Sqrt() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(*<span class="keyword">this</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(*<span class="keyword">this</span> &lt;= <span class="number">1</span>)<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	BigInteger l = <span class="number">0</span>, r = *<span class="keyword">this</span>, mid;</span><br><span class="line">	<span class="keyword">while</span>(r - l &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid * mid &gt; *<span class="keyword">this</span>)</span><br><span class="line">			r = mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::~BigInteger()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-字符串哈希</title>
    <url>/p/114af1e8.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P3370" target="_blank" rel="noopener">洛谷P3370</a></p>
<h4 id="单哈希-自然溢出"><a href="#单哈希-自然溢出" class="headerlink" title="单哈希(自然溢出)"></a>单哈希(自然溢出)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = Ans * base + (ULL)s[i];</span><br><span class="line">    <span class="keyword">return</span> Ans &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单哈希-单模数"><a href="#单哈希-单模数" class="headerlink" title="单哈希(单模数)"></a>单哈希(单模数)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>], mod = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单哈希-大模数"><a href="#单哈希-大模数" class="headerlink" title="单哈希(大模数)"></a>单哈希(大模数)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>], mod = <span class="number">212370440130137957L</span>L;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> prime = <span class="number">233317</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod + prime;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, mod1=<span class="number">19260817</span>, mod2=<span class="number">19660813</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULL x,y;</span><br><span class="line">&#125;a[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash1</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod1;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash2</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod2;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-并查集</title>
    <url>/p/9603fc0b.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, q</code>点数、边数、问题数<br><code>x, y</code>需要合并的两个数<br><code>ufs[]</code>并查集<br><code>find(int)</code>查找并查集中一个数的祖先<br><code>unionn(int, int)</code>合并两个数所在集合</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, x, y, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ufs[x] != x) <span class="keyword">return</span> ufs[x] = find(ufs[x]);</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ufs[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        unionn(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (find(x) == find(y)) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-数论-线性筛素数</title>
    <url>/p/cff9d95.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>p[]</code> 最终结果</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i * p[j];</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-树状数组</title>
    <url>/p/72c90980.html</url>
    <content><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>模板：<a href="https://www.luogu.org/problemnew/show/P3374" target="_blank" rel="noopener">洛谷P3374</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>tree[]</code>树状数组<br><br><code>lowbit(int)</code>神奇的函数<br><br><code>add(int x, int k)</code>第 $x$ 个数加上 $k$ <br><br><code>sum(int x)</code>前 $x$ 个数的和</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tree[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简单用法</title>
    <url>/p/e779c345.html</url>
    <content><![CDATA[<p><code>Git</code>是一款版本控制软件，配合<code>GitHub</code>可以更好的控制代码</p>
<a id="more"></a>
<h3 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"975062472@qq.com"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat id_rsa.pub</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$ mkdir study_cpp</span><br><span class="line">$ cd study_cpp/</span><br><span class="line">$ echo <span class="string">"# test"</span> <span class="meta">&gt;&gt; </span>README.md</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">$ git init</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">"添加 README.md 文件"</span></span><br><span class="line">$ git remote add origin git@github.<span class="symbol">com:</span>Tony031218/study_cpp.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:Tony031218/study_cpp</span><br></pre></td></tr></table></figure>
<h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git fetch origin</span><br><span class="line"><span class="variable">$ </span>git merge origin/master</span><br></pre></td></tr></table></figure>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git add &lt;filename&gt;</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"推送信息"</span></span><br><span class="line"><span class="variable">$ </span>git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote add origin2 git<span class="variable">@github</span>.<span class="symbol">com:</span>Tony031218/study_cpp.git</span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line"><span class="variable">$ </span>git remote rm origin2</span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git checkout -b graph  <span class="comment">//创建分支，并切换过去</span></span><br><span class="line"><span class="symbol">$</span> git checkout master    <span class="comment">//回到主分支</span></span><br><span class="line"><span class="symbol">$</span> git push origin graph  <span class="comment">//将分支推送到远程仓库</span></span><br><span class="line"><span class="symbol">$</span> git pull               <span class="comment">//将本地仓库更新</span></span><br><span class="line"><span class="symbol">$</span> git diff graph master  <span class="comment">//显示差别</span></span><br></pre></td></tr></table></figure>
<h3 id="克隆分支"><a href="#克隆分支" class="headerlink" title="克隆分支"></a>克隆分支</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git clone -<span class="selector-tag">b</span> &lt;branch_name&gt; &lt;repo_url&gt;   <span class="comment">//克隆单个分支</span></span><br><span class="line">$ cd &lt;repo&gt;</span><br><span class="line">$ git branch -<span class="selector-tag">a</span>                           <span class="comment">//查看所有分支</span></span><br><span class="line">$ git checkout -<span class="selector-tag">b</span> &lt;branch_name&gt; origin/&lt;branch_name&gt;  <span class="comment">//关联分支</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-网络流相关</title>
    <url>/p/c3cdab79.html</url>
    <content><![CDATA[<p>网络流算法相关模板,讲解<strong>以后再说吧</strong>,咕咕咕</p>
<a id="more"></a>
<p>注:本文使用<code>vector</code>建图</p>
<h2 id="网络最大流"><a href="#网络最大流" class="headerlink" title="网络最大流"></a>网络最大流</h2><h3 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, s, t, ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): from(u), to(v), cap(c), flow(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdmondsKarp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        a[s] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!a[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    p[e.to] = G[x][i];</span><br><span class="line">                    a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[t]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!a[t]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">            edges[p[u]].flow += a[t];</span><br><span class="line">            edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dinic算法-常用"><a href="#Dinic算法-常用" class="headerlink" title="Dinic算法(常用)"></a>Dinic算法(常用)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.push_back((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += DFS(s, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ISAP算法"><a href="#ISAP算法" class="headerlink" title="ISAP算法"></a>ISAP算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], p[maxn], num[maxn], cur[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): from(u), to(v), cap(c), flow(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(t);</span><br><span class="line">    d[t] = <span class="number">0</span>; vis[t] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.from] = <span class="number">1</span>;</span><br><span class="line">                d[e.from] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.from);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Augment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = t, a = inf;</span><br><span class="line">    <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">        Edge&amp; e = edges[p[x]];</span><br><span class="line">        a = min(a, e.cap - e.flow);</span><br><span class="line">        x = edges[p[x]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    x = t;</span><br><span class="line">    <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">        edges[p[x]].flow += a;</span><br><span class="line">        edges[p[x] ^ <span class="number">1</span>].flow -= a;</span><br><span class="line">        x = edges[p[x]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) num[d[i]]++;</span><br><span class="line">    <span class="keyword">int</span> x = s;</span><br><span class="line">    <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">    <span class="keyword">while</span> (d[s] &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t) &#123;</span><br><span class="line">            flow += Augment();</span><br><span class="line">            x = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + <span class="number">1</span>) &#123;</span><br><span class="line">                ok = <span class="number">1</span>;</span><br><span class="line">                p[e.to] = G[x][i];</span><br><span class="line">                cur[x] = i;</span><br><span class="line">                x = e.to;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="keyword">int</span> mm = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; e.flow) mm = min(mm, d[e.to]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--num[d[x]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            num[d[x] = mm + <span class="number">1</span>]++;</span><br><span class="line">            cur[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (x != s) x = edges[p[x]].from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">    edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = inf;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">                d[e.to] = d[x] + e.cost;</span><br><span class="line">                p[e.to] = G[x][i];</span><br><span class="line">                a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    Q.push(e.to);</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    flow += a[t];</span><br><span class="line">    cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">        edges[p[u]].flow += a[t];</span><br><span class="line">        edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BellmanFord(flow, cost));</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/p/178c0d2c.html</url>
    <content><![CDATA[<p>由于<code>mkdocs</code>上有很多不足，例如没有标签，分类，评论，计数等等，故转至使用<code>Hexo</code>搭建博客，以下是我折腾的过程</p>
<a id="more"></a>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>我是用的是<code>Ubuntu16.04</code>系统，其他系统安装方法可到官网查询<br>在<a href="https://nodejs.org" target="_blank" rel="noopener">nodejs官网</a>下载<code>node.js</code>，并解压<br>添加环境变量<br><code>echo &quot;export PATH=$PATH:/home/tony/node-v8.11.4-linux-x64/bin&quot; &gt;&gt; ~/.zshrc</code>（如果使用的是bash，将最后一句改为<code>~/.bashrc</code>）<br><code>source ~/.zshrc</code>应用更改</p>
<p>下载hexo<br><code>npm install -g hexo-cli</code></p>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure>
<p>使用<code>hexo s</code>启动服务,在浏览器中输入<code>localhost:4000</code>便可看到预览网页</p>
<h3 id="部署到GitPages"><a href="#部署到GitPages" class="headerlink" title="部署到GitPages"></a>部署到GitPages</h3><p>创建<code>&lt;username&gt;.github.io</code>存储库<br>更改<code>_config.yml</code>文件中这一部分<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>hexo d -g</code>发布</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>我当前使用的是<code>maupassant</code>主题<br>详细配置见<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">官方中文文档</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io" target="_blank" rel="noopener">Hexo官网</a><br><a href="https://afar5277.blog.luogu.org/post-zzq-hexoblog" target="_blank" rel="noopener">zzq浅谈用Hexo+GitHub搭建自己的blog</a><br><a href="https://www.luogu.org/blog/0Umaru0/hexo-bo-ke-da-jian-shuo-ming-shu-zhi-bei-shu-post" target="_blank" rel="noopener">Hexo博客搭建说明书（指北书）</a><br><a href="https://www.luogu.org/blog/Venus/build-hexo-github-blog" target="_blank" rel="noopener">从零搭建 Hexo + Github 博客</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/p/3c50d03d.html</url>
    <content><![CDATA[<p><code>Markdown</code>是一款简洁实用的文本标记语言，可以在<code>mkdocs</code>,<code>hexo</code>中使用</p>
<a id="more"></a>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<p>下划线<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">****</span></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p><code>[TOC]</code></p>
<hr>
<h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p><strong>`</strong> <strong>`加粗</strong><br><br><em>`</em> <em>`倾斜</em><br><br><strong><em>`</em></strong> <strong><em>`倾斜加粗</em></strong><br><br><code>~~ ~~</code><del>删除</del></p>
<hr>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><code>&gt;</code>一级 <code>&gt;&gt;</code>二级</p>
<blockquote>
<p>引用</p>
<blockquote>
<p>二级引用</p>
</blockquote>
</blockquote>
<blockquote>
<p>引用</p>
</blockquote>
<hr>
<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p><code>&amp;nbsp; 或 &lt;br/&gt;</code><br>&nbsp;<br><br></p>
<hr>
<h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p><code>&amp;emsp;</code><br><br>&emsp;&emsp;空格</p>
<hr>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><code>![图片名](图片地址 &quot;title&quot;)</code><br><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=d997317c11ce36d3b6098b625b9a51e2/00e93901213fb80ef9ceac7132d12f2eb938947d.jpg" alt="markdown"></p>
<p>或使用html标签<code>&lt;img src=&quot;...&quot; width=&quot;...&quot; height=&quot;...&quot; /&gt;</code></p>
<hr>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><code>[网页名](地址 &quot;title&quot;)</code><br><a href="http://www.baidu.com/" title="百度一下" target="_blank" rel="noopener">百度</a></p>
<hr>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello markdown"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="序表"><a href="#序表" class="headerlink" title="序表"></a>序表</h4><ol>
<li>有序1</li>
<li>有序2</li>
<li>有序3</li>
</ol>
<hr>
<p><code>+ 或 - 或 *</code></p>
<ul>
<li>无序</li>
</ul>
<ul>
<li>无序</li>
</ul>
<ul>
<li>无序</li>
</ul>
<hr>
<ul>
<li>一级无序<ul>
<li>二级无序<ul>
<li>三级无序<ul>
<li>四级无序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><p><code>- [ ] ...</code><br><br><code>- [x] ...</code><br><br><code>mkdocs</code>需要<code>pymdown</code>中的<code>pymdownx</code>模块<br><br><code>GitHub</code>支持</p>
<hr>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">|<span class="symbol">:----------|</span><span class="symbol">:----------</span><span class="symbol">:|----------</span><span class="symbol">:|</span></span><br><span class="line">| 左对齐 |居中|右对齐|</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">表头</th>
<th style="text-align:center">表头</th>
<th style="text-align:right">表头</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">左对齐</td>
<td style="text-align:center">居中</td>
<td style="text-align:right">右对齐</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="内联CSS"><a href="#内联CSS" class="headerlink" title="内联CSS"></a>内联CSS</h4><p><code>&lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: &#39;Consolas&#39;;&quot;&gt;CSS&lt;/p&gt;</code></p>
<p style="color: #AD5D0F;font-size: 30px; font-family: 'Consolas';">CSS</p>

<hr>
<h4 id="语义标记"><a href="#语义标记" class="headerlink" title="语义标记"></a>语义标记</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>强调<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">上标： Z<span class="tag">&lt;<span class="name">sup</span>&gt;</span>a<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">下标： Z<span class="tag">&lt;<span class="name">sub</span>&gt;</span>a<span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span><br><span class="line">键盘文本： <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <i>斜体</i><br><br> <b>加粗</b><br><br> <em>强调</em><br><br> 上标： Z<sup>a</sup><br><br> 下标： Z<sub>a</sub><br><br> 键盘文本： <kbd>Ctrl</kbd><br></p>
<hr>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>文档末尾添加<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-mathjax-config"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">MathJax.Hub.Config(&#123;</span></span><br><span class="line"><span class="actionscript">	  tex2jax: &#123;inlineMath: [[<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">'\\('</span>,<span class="string">'\\)'</span>]]&#125;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用$\LaTeX$语法编写公式<br>$$<br>x \href{why-equal.html} {=} y^2 + 1<br>$$<br>$$<br>x = {-b \pm \sqrt{b^2-4ac} \over 2a}<br>$$</p>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MkDocs使用方法</title>
    <url>/p/ce42b873.html</url>
    <content><![CDATA[<p>mkdocs是一款基于python markdown的项目文档工具,可以用来编写一个网站</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="安装python3及pip"><a href="#安装python3及pip" class="headerlink" title="安装python3及pip"></a>安装python3及pip</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install python3        <span class="comment">#安装python</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install python3-pip    <span class="comment">#安装pip</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 --version               <span class="comment">#检查python是否安装成功</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 --version                  <span class="comment">#检查pip是否安装成功</span></span></span><br></pre></td></tr></table></figure>
<h4 id="安装mkdocs"><a href="#安装mkdocs" class="headerlink" title="安装mkdocs"></a>安装mkdocs</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip3 install mkdocs             <span class="comment">#注意以root权限安装</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdocs --version                <span class="comment">#检查是否安装成功</span></span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs new <span class="built_in">test</span>                 <span class="comment">#创建一个名为test的文件夹,存储代码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>此时的目录结构<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test/</span><br><span class="line"> ├── docs/                        #存放markdown文档</span><br><span class="line"> │     └── index.md               #主页</span><br><span class="line"> └── mkdocs.yml                   #配置文件</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs serve                    <span class="comment">#开启内建服务器</span></span></span><br></pre></td></tr></table></figure>
<p>在浏览器中输入<code>127.0.0.1:8000</code>预览,终端键入<code>Ctrl+C</code>关闭服务器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs build                    <span class="comment">#生成静态网页代码</span></span></span><br></pre></td></tr></table></figure></p>
<p>这时已经生成了<code>site/</code>文件夹,可以将里面的内容部署到网站上了</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>site_name:</code>  <strong><em>必须存在</em></strong>,文档主标题名称<br><code>site_favicon:</code>  图标,存放在<code>docs/</code>文件夹下<br><code>theme:</code>  主题样式例如:<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">'material'</span>                <span class="comment">#使用material主题,需要pip安装mkdocs-material</span></span><br><span class="line"><span class="attr">  language:</span> <span class="string">'zh'</span>                  <span class="comment">#使用中文</span></span><br><span class="line"><span class="attr">  feature:</span></span><br><span class="line"><span class="attr">    tabs:</span> <span class="literal">true</span>                    <span class="comment">#使用上方tab栏（可改为false）</span></span><br></pre></td></tr></table></figure></p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line"><span class="attr">  - 'Index':</span> <span class="string">index.md</span></span><br><span class="line"><span class="attr">  - 'About':</span> <span class="string">about.md</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>执行<code>$ pip3 install pymdown-extensions</code>安装扩展包<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown_extensions:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">admonition</span>                    <span class="comment">#支持注解</span></span><br><span class="line"><span class="attr">  - codehilite:</span>                   <span class="comment">#代码块高亮</span></span><br><span class="line"><span class="attr">      linenums:</span> <span class="literal">true</span>              <span class="comment">#代码块显示行号</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pymdownx.tasklist</span>             <span class="comment">#支持任务列表</span></span><br></pre></td></tr></table></figure></p>
<p>!!! warning “注意”<br>    一定要事先安装好扩展，否则不能出现预期效果</p>
<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://markdown-docs-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">MkDocs中文文档</a><br><a href="https://www.mkdocs.org/" target="_blank" rel="noopener">MkDocs官方文档</a><br><a href="https://cyent.github.io/markdown-with-mkdocs-material" target="_blank" rel="noopener">cyent的教程</a></p>
]]></content>
      <tags>
        <tag>blog</tag>
        <tag>markdown</tag>
        <tag>mkdocs</tag>
      </tags>
  </entry>
  <entry>
    <title>manim教程系列-颜色 笔记</title>
    <url>/p/2e2c9a7.html</url>
    <content><![CDATA[<p>这篇文章是在写 <strong>manim教程系列视频</strong> 的 <em>颜色</em> 部分时做的一些笔记,包括 整个视频的结构 和 写代码时了解的一些用法的笔记<br>视频已经发布,地址:<a href="https://www.bilibili.com/video/BV1vZ4y1x7hT" target="_blank" rel="noopener">BV1vZ4y1x7hT</a></p>
<a id="more"></a>
<h2 id="视频结构大纲"><a href="#视频结构大纲" class="headerlink" title="视频结构大纲"></a>视频结构大纲</h2><ol start="0">
<li style="list-style: none"><input type="checkbox" checked> 开头<ul>
<li>开始,标题,展示所有要将的方法</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox" checked> 颜色的表示<ul>
<li>所有<code>constants.py</code>中的颜色常量</li>
<li>使用hex表示颜色</li>
<li>使用rgb的ndarray表示颜色</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox" checked> 颜色之间的转换<ul>
<li><code>rgb_to_hex</code></li>
<li><code>hex_to_rgb</code></li>
<li><code>color_to_rgb</code></li>
<li><code>rgb_to_color</code></li>
<li><code>color_to_int_rgb</code></li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox" checked> 颜色的运算函数<ul>
<li><code>invert_color</code></li>
<li><code>color_gradient</code></li>
<li><code>interpolate_color</code></li>
<li><code>average_color</code></li>
<li><code>random_color</code></li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox" checked> 设置颜色<ul>
<li><code>Mobject</code>略,一般上色的都为<code>VMobject</code></li>
<li><code>color</code>分为<code>stroke_color</code>和<code>fill_color</code></li>
<li>传入<code>color</code>, <code>stroke_color</code>, <code>fill_color</code></li>
<li><code>set_color</code>, <code>set_stroke</code>, <code>set_fill</code>方法的<code>color</code>和<code>opacity</code></li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox" checked> 给子物体上色<ul>
<li><code>set_color</code></li>
<li><code>set_color_by_gradient</code></li>
<li><code>set_colors_by_radial_gradient</code></li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox" checked> 光泽与渐变色<ul>
<li><code>set_sheen</code></li>
<li><code>set_color</code>中使用列表达到渐变色</li>
</ul>
</li>
</ol>
<h2 id="一些码视频时的笔记"><a href="#一些码视频时的笔记" class="headerlink" title="一些码视频时的笔记"></a>一些码视频时的笔记</h2><ul>
<li><code>isinstance</code>函数检测对象的类型</li>
<li>对一个字符串进行format时,想要用空格补齐左边到一定个数,可以使用<code>str(...).rjust(num)</code></li>
<li>涉及到<code>Transform</code>Text的地方,在Text里面不可以有空格,需要用白色的<code>~</code>来做出伪空格</li>
<li>字符串中查找一个字符的下标可以用<code>.index(&quot; &quot;, beg=..., end=...)</code>方法来查找第一次出现的位置,第二次出现需要传入<code>beg</code>为第一次位置+1</li>
<li>manim的<code>rgb_to_color</code>函数传入的rgb的值为0~1,不是0~255</li>
<li>用for循环遍历字典键值对<code>for key, value in dic.items():</code>,遍历其中一部分<code>for key, value in list(dic.items())[1:3]</code>将键值对转化为列表,并用切片</li>
<li><code>Arrow</code>的箭头为<code>.tip</code></li>
<li><code>.keys(),.values()</code>不为列表,需要套在<code>list()</code>里面</li>
<li><code>set_colors_by_radial_gradient</code>利用中心与center的距离对颜色进行插值,radius外的所有子物体全为outer_color颜色</li>
<li>含有<code>sheen_factor</code>的物体设置渐变色后与sheen_factor无关</li>
</ul>
]]></content>
      <categories>
        <category>manim</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>manim</tag>
        <tag>python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-背包问题</title>
    <url>/p/990bbe9a.html</url>
    <content><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 $n$ 件物品，和一容积为 $V$ 的背包，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>由题意易知状态转移方程： $F_{i,j} = max(F_{i-1,j}\ , F_{i-1,j-w_i} + c_i)$</p>
<p>$F_{i, j}$ 为前 $i$ 件物品放入容量为 $V$ 的背包中最大价值<br><br>时间复杂度 $O(n\times V)$ ，空间复杂度 $O(n\times V)$</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>注意倒序，保证<code>f[n][V]</code>为结果<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[n][V])</span><br></pre></td></tr></table></figure></p>
<h4 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h4><p>降至一维数组<br><br>时间复杂度 $O(n\times V)$ ，空间复杂度 $O(V)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = max(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[V]);</span><br></pre></td></tr></table></figure></p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有 $n$ 种物品（每种 <strong>无限件</strong> ），和一容积为 $V$ 的背包，第 $i$ 种物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几种物品取任意件装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>将<a href="../pack#01背包问题">01背包</a>第二个循环改为正序即可<br><br>状态转移方程：$F_j = max(F_j\ , F_{j-w_i}+c_i)$</p>
<h4 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= V; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = max(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[V]);</span><br></pre></td></tr></table></figure>
<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h3 id="解法-I-化为完全背包"><a href="#解法-I-化为完全背包" class="headerlink" title="解法 $I.$ 化为完全背包"></a>解法 $I.$ 化为完全背包</h3><p>状态转移方程：$F_{i,v} = max(F_{i-1,v-k\times w_i} + k\times c_i | 0\leqslant k\leqslant n_i)$<br><br>时间复杂度：$O(V\times \sum{n_i})$</p>
<h4 id="框架-2"><a href="#框架-2" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n[i]; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = max(f[i - <span class="number">1</span>][j], [i - <span class="number">1</span>][j - k * w[i]] + k * c[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[N][V]);</span><br></pre></td></tr></table></figure>
<h3 id="解法-II-化为01背包"><a href="#解法-II-化为01背包" class="headerlink" title="解法 $II.$ 化为01背包"></a>解法 $II.$ 化为01背包</h3><p>把 $n_i$ 件一种物品化为单独的 $n_i$ 件物品即可<br><br>时间复杂度：$O(V\times \sum{n_i})$<br><br>框架略</p>
<h3 id="解法-III-二进制优化"><a href="#解法-III-二进制优化" class="headerlink" title="解法 $III.$ 二进制优化"></a>解法 $III.$ 二进制优化</h3><p>$$<br>n_i\to 1+2+4+\dots +2^{k-1}+\dots +(n_i-2^k+1)<br>$$<br>$$<br>\sum{n_i}\to \sum{\log_2{n_i}}<br>$$<br>时间复杂度：$O(V\times \sum{\log_2{n_i}})$</p>
<h4 id="框架-3"><a href="#框架-3" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> w, c, n, t = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;w, &amp;c, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n &gt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">        v[++N] = x * t;</span><br><span class="line">        w[N]   = y * t;</span><br><span class="line">        n -= t;</span><br><span class="line">        t *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v[++N] = x * n;</span><br><span class="line">    w[N]   = y * n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i]; --j)</span><br><span class="line">        f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[V]);</span><br></pre></td></tr></table></figure>
<h2 id="混合三种背包问题"><a href="#混合三种背包问题" class="headerlink" title="混合三种背包问题"></a>混合三种背包问题</h2><p>有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件或无穷件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h4 id="伪框架"><a href="#伪框架" class="headerlink" title="伪框架"></a>伪框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (第i件是有穷件)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            f[j] = max(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//有无穷件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            f[j] = max(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h2><p>有 $N$ 件物品，容积为 $V,U$ 的两个背包，每件物品有两种费用，选择物品需要付出两种代价，第 $i$ 件代价为 $a_i,b_i$，价值为 $c_i$。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>改为二维数组即可<br><br>状态转移方程：$F_{v,u} = max(F_{v,u}\ , F_{v-a_i,u-b_i} + c_i)$<br><br>$F_{v,u}$ 表示前面的物品付出代价分别为 $v,u$ 时的最大价值<br><br>框架略</p>
<p>循环顺序</p>
<ul>
<li>类01背包：<code>v = V..0  u = U..0</code><br></li>
<li>类完全背包：<code>v = 0..V  u = 0..U</code><br></li>
<li>类多重背包：拆分物品</li>
</ul>
<h2 id="分组的背包问题"><a href="#分组的背包问题" class="headerlink" title="分组的背包问题"></a>分组的背包问题</h2><p>有 $K$ 组物品， $V$ 的背包，第 $k$ 组有 $N_k$ 件物品，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ ，每组中只能选一件物品。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h4 id="框架-4"><a href="#框架-4" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = V; v &gt;= <span class="number">0</span>; --v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N[k]; ++i)</span><br><span class="line">            f[v] = max(f[v], f[v - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包问题的方案数"><a href="#背包问题的方案数" class="headerlink" title="背包问题的方案数"></a>背包问题的方案数</h2><p>状态转移方程：$F_{i,v} = sum(F_{i-1,v}, F_{i-1,v-w_i})\ \ \ (F_{0,0} = 1)$</p>
<h4 id="框架-5"><a href="#框架-5" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= V; ++j)</span><br><span class="line">        f[j] += f[j - w[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[V]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1494」小Z的袜子-题解</title>
    <url>/p/49548215.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P1494" target="_blank" rel="noopener">「Luogu P1494」小Z的袜子</a><br>一道推公式，后使用莫队 <del>玄学</del> 优化的题目</p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n$个袜子,第$i$只袜子的颜色为$c_i$<br>有$m$个询问,用$L,R$表示<br>在区间$[L,R]$中随机取袜子,求取出两只袜子颜色相同的概率(最简分数)</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑区间$[L,R]$,其中颜色为$A$的袜子有$a$只,颜色为$B$的袜子有$b$只$…$</p>
<p>取出两只袜子的总情况数为<br>$$C_{R-L+1}^2=\frac{(R-L+1)(R-L)}{2}$$<br>取出两只袜子颜色都为$A$的情况数为<br>$$C_a^2=\frac{a(a - 1)}{2}$$<br>所以,取出两只袜子颜色相同的情况数为<br>$$\sum_{i}C_i^2=C_a^2+C_b^2+…=\frac{a(a-1)}{2}+\frac{b(b-1)}{2}+…$$<br>所以最终的概率为<br>$$<br>\begin{aligned}<br>P&amp;=\frac{\displaystyle\sum_{i}C_i^2}{C_{R-L+1}^2}\\\\<br>&amp;=\dfrac{\dfrac{a(a-1)}{2}+\dfrac{b(b-1)}{2}+…}{ \dfrac{(R-L+1)(R-L)}{2} }\\\\<br>&amp;=\dfrac{a^2+b^2+…-a-b-…}{(R-L+1)(R-L)}\\\\<br>&amp;=\dfrac{\displaystyle\sum_ii^2-\displaystyle\sum_ii}{(R-L+1)(R-L)}\\\\<br>&amp;=\dfrac{\displaystyle\sum_ii^2-(R-L+1)}{(R-L+1)(R-L)}<br>\end{aligned}<br>$$<br>所以要求的就是$\displaystyle\sum_ii^2$,可以用莫队来维护区间平方和得到</p>
<p>对于最终结果的表达式,令$a=$分子,$b=$分母,求出$ab$的最大公约数,并除去<br>最终答案即为$a/b$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, pos, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">if</span> (a.pos &amp; <span class="number">1</span>) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    <span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span> &#123;</span></span><br><span class="line">    LL a, b;</span><br><span class="line">&#125;ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, Ans, len;</span><br><span class="line">LL c[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Ans -= cnt[c[x]] * cnt[c[x]];</span><br><span class="line">    cnt[c[x]]--;</span><br><span class="line">    Ans += cnt[c[x]] * cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Ans -= cnt[c[x]] * cnt[c[x]];</span><br><span class="line">    cnt[c[x]]++;</span><br><span class="line">    Ans += cnt[c[x]] * cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read(); len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = read(); q[i].r = read();</span><br><span class="line">        q[i].id = i; q[i].pos = q[i].l / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) del(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) del(r--);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) add(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) add(++r);</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ans[q[i].id].a = <span class="number">0</span>; ans[q[i].id].b = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL a = Ans - (r - l + <span class="number">1</span>);</span><br><span class="line">        LL b = <span class="number">1L</span>L * (r - l + <span class="number">1</span>) * (LL)(r - l);</span><br><span class="line">        LL g = gcd(a, b);</span><br><span class="line">        ans[q[i].id].a = a / g;</span><br><span class="line">        ans[q[i].id].b = b / g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>, ans[i].a, ans[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>莫队</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2019」题解</title>
    <url>/p/7d7252b1.html</url>
    <content><![CDATA[<pre><code>~~今年的题真是毒瘤~~,一个蒟蒻要来写题解了
</code></pre><p>校门外有两棵树,一棵叫括号树一棵叫树上的数,这两棵树要被一匹叫格雷的马划分开为Emiya做饭,这两棵树问:那你猜猜我们的重心在哪啊</p>
<a id="more"></a>
<h2 id="D1T1-格雷码"><a href="#D1T1-格雷码" class="headerlink" title="$D1T1$ 格雷码"></a>$D1T1$ <a href="https://www.luogu.org/problem/P5657" target="_blank" rel="noopener">格雷码</a></h2><h3 id="沙雕暴力dfs-我的做法"><a href="#沙雕暴力dfs-我的做法" class="headerlink" title="沙雕暴力dfs(我的做法)"></a><del>沙雕</del>暴力<code>dfs</code>(我的做法)</h3><p>考场上真是脑残了,拿dfs模拟,忘了二分的事了,还传了四个参数<br>注意:<strong>一定要用<code>unsigned long long</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ull x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar(); &#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">ull n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ull n, ull k, ull rev, ull from)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= (<span class="number">1L</span>L &lt;&lt; (n - <span class="number">1L</span>L)) - <span class="number">1L</span>L) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">			dfs(n - <span class="number">1L</span>L, k, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">			dfs(n - <span class="number">1L</span>L, k, <span class="number">1L</span>L, <span class="number">0L</span>L);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">1</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">			dfs(n - <span class="number">1L</span>L, k, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">			dfs(n - <span class="number">1L</span>L, k, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">			dfs(n - <span class="number">1L</span>L, k - (<span class="number">1L</span>L &lt;&lt; (n - <span class="number">1L</span>L)), <span class="number">1L</span>L, <span class="number">1L</span>L);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">1</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">			dfs(n - <span class="number">1L</span>L, k - (<span class="number">1L</span>L &lt;&lt; (n - <span class="number">1L</span>L)), <span class="number">0L</span>L, <span class="number">1L</span>L);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">			dfs(n - <span class="number">1L</span>L, k - (<span class="number">1L</span>L &lt;&lt; (n - <span class="number">1L</span>L)), <span class="number">0L</span>L, <span class="number">1L</span>L);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">			dfs(n - <span class="number">1L</span>L, k - (<span class="number">1L</span>L &lt;&lt; (n - <span class="number">1L</span>L)), <span class="number">1L</span>L, <span class="number">1L</span>L);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(); k = read();</span><br><span class="line">	dfs(n, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 55ms 812kB */</span></span><br></pre></td></tr></table></figure>
<h3 id="二分模拟-lyd-巨佬的做法"><a href="#二分模拟-lyd-巨佬的做法" class="headerlink" title="二分模拟($lyd$巨佬的做法)"></a>二分模拟($lyd$巨佬的做法)</h3><p>考前做过一道类似的题,但可惜我忘了<br>$lyd$巨佬说他这题只做了15分钟</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n,k;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> two[<span class="number">65</span>];</span><br><span class="line"><span class="keyword">int</span> change=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	two[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">63</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		two[i]=two[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;=two[n<span class="number">-1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!change)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">				change^=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			k-=two[n<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(change)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">				change^=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 57ms 928kB */</span></span><br></pre></td></tr></table></figure>
<h3 id="位运算正解"><a href="#位运算正解" class="headerlink" title="位运算正解"></a>位运算正解</h3><p>格雷码的规律就是<br>第$i$位为$k\ xor\ \lfloor\frac{k}{2}\rfloor$的第$i$位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %llu"</span>, &amp;n, &amp;k);</span><br><span class="line">    k ^= (k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, (k &gt;&gt; n &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 54ms 932kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D1T2-括号树"><a href="#D1T2-括号树" class="headerlink" title="$D1T2$ 括号树"></a>$D1T2$ <a href="https://www.luogu.org/problem/P5658" target="_blank" rel="noopener">括号树</a></h2><p>后面的先咕着,等着补</p>
<h2 id="D1T3-树上的数"><a href="#D1T3-树上的数" class="headerlink" title="$D1T3$ 树上的数"></a>$D1T3$ <a href="https://www.luogu.org/problem/P5659" target="_blank" rel="noopener">树上的数</a></h2><h2 id="D2T1-Emiya-家今天的饭"><a href="#D2T1-Emiya-家今天的饭" class="headerlink" title="$D2T1$ $Emiya$家今天的饭"></a>$D2T1$ <a href="https://www.luogu.org/problem/P5664" target="_blank" rel="noopener">$Emiya$家今天的饭</a></h2><h2 id="D2T2-划分"><a href="#D2T2-划分" class="headerlink" title="$D2T2$ 划分"></a>$D2T2$ <a href="https://www.luogu.org/problem/P5665" target="_blank" rel="noopener">划分</a></h2><h2 id="D2T3-树的重心"><a href="#D2T3-树的重心" class="headerlink" title="$D2T3$ 树的重心"></a>$D2T3$ <a href="https://www.luogu.org/problem/P5666" target="_blank" rel="noopener">树的重心</a></h2>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>CSP-S</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux美化方案</title>
    <url>/p/f2ddc0e6.html</url>
    <content><![CDATA[<h3 id="I-初步系统优化"><a href="#I-初步系统优化" class="headerlink" title="I. 初步系统优化"></a>I. 初步系统优化</h3><hr>
<ul>
<li>更改系统时间</li>
<li>安装python<br>  <code>sudo apt install python</code></li>
<li>安装git并添加ssh密钥<br>  <code>sudo apt install git</code><br>  <code>git config --global user.name &quot;your_name&quot;</code><br>  <code>git config --global user.email &quot;you@example.com&quot;</code><br>  <code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>一路回车<br>  <code>cat ~/.ssh/id_rsa.pub</code>并复制粘贴到github上<br>  <code>ssh -T git@github.com</code>测试<br>  <code>git clone https://github.com/Tony031218/Beautiful_Linux.git</code>克隆下本仓库</li>
<li>添加语言<pre>
  settings -> Region&Language -> manage installed language -> install/remove languages
                              -> input sources
</pre></li>
<li>软件更新<br>  <code>sudo apt update</code><br>  <code>sudo apt upgrade</code></li>
<li>安装GDebi<br>  <code>sudo apt install gdebi</code></li>
<li>卸载libreoffice 安装 WPS(可选)<br>  <code>sudo apt remove libreoffice-common</code><br>  从<a href="http://www.wps.cn/product/wpslinux/" target="_blank" rel="noopener">http://www.wps.cn/product/wpslinux/</a> 上下载WPS<br>  <code>sudo dpkg -i wps-office_10.1.0.6757_amd64.deb</code></li>
<li>卸载firefox 安装 Chrome(可选)<br>  <code>sudo apt remove firefox</code><br>  <code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code><br>  <code>sudo dpkg -i google-chrome*</code><br>  <code>sudo apt -f install</code></li>
<li>更换更新源<br>  左下角 -&gt; all -&gt; Software&amp;Updates<br>  <code>sudo apt update</code></li>
<li>安装vim<br>  <code>sudo apt install vim</code></li>
<li>菜单栏位置<br>  <code>gsettings set com.canonical.Unity.Launcher launcher-position Bottom</code>底部<br>  <code>gsettings set com.canonical.Unity.Launcher launcher-position Left</code>左侧</li>
</ul>
<h3 id="II-主题配置"><a href="#II-主题配置" class="headerlink" title="II. 主题配置"></a>II. 主题配置</h3><hr>
<ul>
<li><p>安装 Unity-tweak-tool<br><code>sudo apt install unity-tweak-tool</code><br>如果出现报错需要安装缺失的包</p>
</li>
<li><p>安装 Flatabulous 主题<br><code>sudo add-apt-repository ppa:noobslab/themes</code><br><code>sudo apt update</code><br><code>sudo apt install flatabulous-theme</code>主题<br><code>sudo add-apt-repository ppa:noobslab/icons</code><br><code>sudo apt update</code><br><code>sudo apt install ultra-flat-icons</code>图标<br>unity-tweak-tool -&gt; 主题/图标</p>
</li>
<li><p>字体<br>Monaco Powerline 也可以选择其他字体,但一定要支持Powerline的,否则后文会出现乱码</p>
</li>
</ul>
<h3 id="III-终端Terminal美化"><a href="#III-终端Terminal美化" class="headerlink" title="III. 终端Terminal美化"></a>III. 终端Terminal美化</h3><hr>
<ul>
<li>Terminal zsh<br>  <code>sudo apt install zsh</code><br>  <code>git clone https://github.com/robbyrussell/oh-my-zsh.git</code><br>  <code>cd oh-my-zsh/tools</code><br>  <code>./install.sh</code></li>
<li>更换默认shell<br>  <code>chsh</code>按步骤来输入zsh地址</li>
<li>zsh插件<ul>
<li>自动补全<br>  <code>git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></li>
<li>快速跳转<br>  <code>git clone https://github.com/joelthelion/autojump.git</code><br>  <code>cd autojump</code><br>  <code>./install.py</code>按要求把代码填写到~/.zshrc文件尾</li>
<li>配置<br>  <code>vim ~/.zshrc</code><br>  修改60行左右的plugins<code>plugins=(git autojump zsh-suggestions)</code></li>
<li>修改皮肤<br>  <code>~/.zshrc</code>中的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>更改</li>
</ul>
</li>
</ul>
<h3 id="IV-vim美化"><a href="#IV-vim美化" class="headerlink" title="IV. vim美化"></a>IV. vim美化</h3><hr>
<ul>
<li>molokai<br>  <code>mkdir ~/.vim/colors</code><br>  将本仓库中的<code>molokai.vim</code>复制到<code>~/.vim/colors/</code>下</li>
<li>Powerline<br>  <code>sudo apt install python-pip</code><br>  <code>pip install git+git://github.com/powerline/powerline</code><br>  <code>pip show powerline-status</code><br>  按照具体位置更改<code>~/.vimrc</code>中的<code>set rtp+=...</code>一行(后文)</li>
<li>插件<ul>
<li>pathogen插件管理<br>  <code>mkdir -p ~/.vim/autoload ~/.vim/bundle</code><br>  <code>curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</code></li>
<li>nerdtree文件浏览器<br>  <code>cd ~/.vim/bundle</code><br>  <code>git clone https://github.com/scrooloose/nerdtree.git</code></li>
<li>taglist大纲界面<br><a href="https://www.vim.org/scripts/scripts.php?script_id=273" target="_blank" rel="noopener">taglist官网</a><br>  下载后解压到<code>~/.vim/bundle/</code>下</li>
</ul>
</li>
<li>vimrc<br>  将本仓库中的<code>vimrc.txt</code>复制到<code>~/.vimrc</code>中<br>  内包含括号匹配,html标签匹配,powerline配置(可能需要改动),cpp.sh.java.py的文件头自动输入,插件的配置(F3打开nerdtree,F4打开taglist)</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="https://blog.csdn.net/qq_35208390/article/details/78441013" target="_blank" rel="noopener">CSDN博客</a><br><a href="https://www.linuxprobe.com/use-powerline-for-bash.html" target="_blank" rel="noopener">powerline</a><br><a href="https://blog.csdn.net/zcube/article/details/42525973" target="_blank" rel="noopener">vim插件</a><br><a href="https://github.com/ocxo/monaco-powerline-vim" target="_blank" rel="noopener">monaco powerline字体</a><br><a href="https://github.com/sickill/vim-monokai" target="_blank" rel="noopener">monokai主题</a><br><a href="http://www.wps.cn/product/wpslinux/" target="_blank" rel="noopener">WPS</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1516」青蛙的约会-题解</title>
    <url>/p/1f4bfad8.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P1516" target="_blank" rel="noopener">「Luogu P1516」青蛙的约会</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>(规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴)<br>现有两只青蛙$A,B$<br>设青蛙$A$的出发点坐标是$x$，青蛙$B$的出发点坐标是$y$<br>青蛙$A$一次能跳$m$米，青蛙$B$一次能跳$n$米，两只青蛙跳一次所花费的时间相同<br>纬度线总长$l$米<br>求两只青蛙跳了几次以后才会碰面</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong><em>同余方程</em></strong>模板题<br>求解$x + km\equiv y + kn \pmod l$</p>
<p>$Solve:$<br>$$<br>x+km−(y+kn)=lz,\ \ z\in Z\\<br>(x-y)+k(m-n)-lz=0\\<br>k(n-m)+lz=(x-y)<br>$$<br>令$a=x-y,b=n-m$<br>上式可化为:<br>$$<br>kb+lz=a<br>$$<br>求这个方程的最小整数解<br>化为求此不定方程最小整数解<br>$$k’b+lz’=gcd(b,l)$$<br>使用扩展欧几里得算法可得一组特解$(k’,b’)$<br>最小解为$k_{min} = k’\bmod \frac{l}{gcd(b,l)}$<br>以上解$k_{min}$的方程右边是$gcd(b,l)$而不是$a$<br>所以结果为<br>$$\boxed{ (k’\times \frac{a}{gcd(b,l)})\bmod \frac{l}{gcd(b,l)} }$$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123; d = a; x = <span class="number">1</span>; y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; exgcd(b, a % b, d, y, x); y -= x * (a / b); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n, m, x, y, l, gcd, x1, y1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld %lld %lld"</span>, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l);</span><br><span class="line">    LL b = n - m, a = x - y;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123; b = -b, a = -a; &#125;</span><br><span class="line">    exgcd(b, l, gcd, x1, y1);</span><br><span class="line">    <span class="keyword">if</span> (a % gcd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LL ans = ((x1 * (a / gcd)) % (l / gcd) + (l / gcd)) % (l / gcd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 26ms 916kB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2019」自闭游记</title>
    <url>/p/1901119c.html</url>
    <content><![CDATA[<p>这次大概是第二年参加信息竞赛了(<del>虽然去年什么也不会就摸了110分,省四</del>)<br>按照惯例,该写篇游记(<del>流水账</del>)了</p>
<a id="more"></a>
<h2 id="Day-7-sim-2"><a href="#Day-7-sim-2" class="headerlink" title="$Day\ \  -7\sim -2$"></a>$Day\ \  -7\sim -2$</h2><p>本来还是挺有信心的,校内几十次模拟赛考自闭了,想想复赛结束后周一周二就要期中考试(<del>其实是”贴心”的年级组特意为我们OIer调的</del>)更自闭了<br>晚饭回来后,几个沙雕朋友听说我自闭了,围了一圈给我来了一遍<a href="https://www.bilibili.com/video/av53058902?from=search&amp;seid=3943401388874538351" target="_blank" rel="noopener">奥利给</a>,真的感动<br>回家和父母商量好,签了个申请书脱了一周产,还说让我专心学信息,期中考试先放下</p>
<p>脱产的时光还是很快乐的<br>早上六点多到校就开始整理模板,刷模板题<br>老师到了之后花三个半小时做模拟题<br>下午自习和$zty$巨佬研究问题<br>四天就这么过去了,打了一本子模板带去省城复习</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="$Day\ \ -1$"></a>$Day\ \ -1$</h2><p>上午十一点和机房$wjh$,$mjc$,$lyd$(<del>lyd AK IOI</del>)出发去车站了<br>还是去年的时间,还是去年的$KFC$,还是去年的垃圾笔记本<br>看的是累积了一年的数千行模板和经验</p>
<p>中午到了去年同样的酒店,晚上去了去年同样的吉大日新楼吃饭<br>回到酒店,$lyd$巨佬给同学讲爆搜技巧,$zyc$学长像去年一样来探望<del>苦逼的</del>$yzOIer$<br>睡前敲了一堆板子:快读,vim配置,ST表,树状数组,Trie树,树的重心,树的直径</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="$Day\ \ 1$"></a>$Day\ \ 1$</h2><p>还是在去年的等候室</p>
<p>进考场<br>$???$这防窥膜是什么鬼,什么都挡不了的好吧,看着还超难受<br>前排的灯也没有开,没开考眼睛就生疼</p>
<h3 id="Day1-T1"><a href="#Day1-T1" class="headerlink" title="$Day1\ T1$"></a>$Day1\ T1$</h3><p>看见题目,emmm怎么做都告诉你了,开个数组<code>reverse</code>模拟呗…<br>emmm不对,数组的话貌似要开$2^64$,不行不行<br>推规律,好像也就那么个意思,<code>dfs</code>模拟!!<br>然后一顿乱搞,dfs传值从2到3到4,写了好几十行<code>dfs</code><br>跑一边样例,没问题,大样例??好像爆了,改<code>long long</code>…照样爆<br>看一眼时间,艹一个小时了,得了得了,不改了</p>
<p>看完第二题,不行不行,得改完,$2^64$?不是<code>unsigned long long</code>吗<br>又加了常数的转换操作,大概可以了</p>
<p>此时一个半小时过去了…</p>
<h3 id="Day1-T2"><a href="#Day1-T2" class="headerlink" title="$Day1\ T2$"></a>$Day1\ T2$</h3><p>emmm括号匹配,靠前看过类似的,好像得用栈<br>一顿乱搞,发现审错题了…<br>树上??我应该不会,做链的小数据$35$分得了<br>自己出了几个样例(其实是没发现大样例有链上情况),用了$multiset,stack$乱搞,都过了,就扔下去看第三题了</p>
<h3 id="Day1-T3"><a href="#Day1-T3" class="headerlink" title="$Day1\ T3$"></a>$Day1\ T3$</h3><p>题目绕了十分多种,看了好几遍样例才明白题干<br>这咋做啊,正解肯定不会,链和菊花图想了半个多小时没想出来</p>
<p>最后剩二十分钟了,不还是有$n!$的暴力$10$分吗<br>飞速写完代码,编译…<code>vector</code>没有???不应该啊,改了好多遍也过不了,拉倒,随机数吧…随机数概率太小,从$1\sim n$依次输出..</p>
<p><del>其实编译没过是没有加<code>using namespace std;</code></del></p>
<p>中午老师请客去了去年同样的饭店,下午去了去年同样的欢乐城放松<del>自暴自弃</del><br>$day1$估分$135$,完了,明天得考一百多分才稳…</p>
<p>晚上睡前又看了看一天什么没用上的模板</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="$Day\ \ 2$"></a>$Day\ \ 2$</h2><p>在等候室看了树的重心,树的直径的模板<br>我跟lyd说:昨天没考,今天肯定有</p>
<h3 id="Day2-T1"><a href="#Day2-T1" class="headerlink" title="$Day2\ T1$"></a>$Day2\ T1$</h3><p>认真的审了题,想要$AC$<br>画了样例的图,woc二分图,网络流???<br>完了完了,考前没看,扔下一个$32$分$n!$暴力溜了</p>
<p><del>其实已经花了一个小时了</del></p>
<h3 id="Day2-T3"><a href="#Day2-T3" class="headerlink" title="$Day2\ T3$"></a>$Day2\ T3$</h3><p>第二题没看懂题面,看到第三题题目我就来了<br>$???$这个重心定义和我复习的不一样,大体思想差不多,开写</p>
<p>改了模板,写了上去,发现分割树???以前没做过,只好重新建图,删一条边建一次图<del>辣鸡效率</del><br>跑完???重心全是$2$,查了半天发现两棵树的节点数没处理…<br>改过来之后前几个点$25$分应该是没问题了</p>
<p>简单推了下链和完美二叉树,没推出来,放弃…<br>考试结束前也没想出来</p>
<h3 id="Day2-T2"><a href="#Day2-T2" class="headerlink" title="$Day2\ T2$"></a>$Day2\ T2$</h3><p>照着样例看了十分钟才明白题目啥意思<br>感觉应该是$DP$,但蒟蒻不会$DP$啊<br>算了,瞎写个状态转移方程吧,乱搞…<br>发现不是最优解,然后处理分块还有贪心什么的<br>改了一个小时还是不对,心想算了,爆零了,1=无缘了,又回去推链的重心</p>
<p>考试结束前,准备提交代码,把这题中间几行没用的删了删(<del>删少了几行</del>),再跑一遍,奇迹般的对了<br>测了一下几个样例,$0\to 64\ \ ???$</p>
<p>估分$100+35+0+32+64+25=256$,有点悬</p>
<p>下午刷洛谷,<code>橙蓝黑紫黑紫</code>…炸了(<del>现在掉色了</del>)<br><img src="https://i0.hdslb.com/bfs/album/cc13d523f06cd8315aed8d91a83f36d030bd0b73.jpg" alt="橙蓝黑紫黑紫"><br>晚上从车站回家在大雪里打车半个小时,到家颓废,第二天的期中彻底放弃</p>
<h2 id="Day-3-sim-4"><a href="#Day-3-sim-4" class="headerlink" title="$Day\ \ 3\sim 4$"></a>$Day\ \ 3\sim 4$</h2><p>期中考试<br>第一天开幕雷击,语文古文没背过,作文主旋律,然后三科一个月没学的文科,还有什么都没复习的英语</p>
<p>回家,老师传了公示代码,去$luogu$民间数据自测<br>$Day1\ T2\ \ 35\to 0\ 256\to 221$ 1=没希望,彻底自闭了,要$AFO$了</p>
<h2 id="Day-5-sim-6"><a href="#Day-5-sim-6" class="headerlink" title="$Day\ \ 5\sim 6$"></a>$Day\ \ 5\sim 6$</h2><p>中午去机房把东西收拾到小屋里,$zty,lyd$巨佬已经开始准备省选<br>期中成绩陆续出来了,总体来说还可以</p>
<p>中午和$zty$用<a href="https://github.com/Sojiv/Project_lemon" target="_blank" rel="noopener">lemon</a>把全省代码拿民间数据跑了一遍,排名还可以,貌似还有希望</p>
<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>虽然考的很水,但学$OI$我绝不后悔<br>接下来要努力捡起文化课了</p>
<blockquote>
<p>文化课虽说恶心，但只有一年，一年完了就能读大学了，高考就与你无关了。 —$zcysky$</p>
</blockquote>
<p>加油!奥利给!!</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>CSP-S</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P2723 P1631 P2850」小练习-题解</title>
    <url>/p/1faf5003.html</url>
    <content><![CDATA[<p>战神留的还有一道<a href="https://www.luogu.org/problemnew/show/P3378" target="_blank" rel="noopener">「P3378」堆</a>,但是是模板,就不用多说了吧</p>
<a id="more"></a>
<h2 id="mathcal-「P2723」-丑数"><a href="#mathcal-「P2723」-丑数" class="headerlink" title="$\mathcal{「P2723」}$ 丑数"></a>$\mathcal{「P2723」}$ <a href="https://www.luogu.org/problemnew/show/P2723" target="_blank" rel="noopener">丑数</a></h2><h3 id="92-分-STL-做法"><a href="#92-分-STL-做法" class="headerlink" title="$92$分$STL$做法"></a>$92$分$STL$做法</h3><p>思路很简单,每次弹出堆顶,依次乘$S$集合内的数,再压入优先队列($priority\_queue$)和集合($set$,目的是去重)中,输出最后一个堆顶即可<br>然而第$4$个点卡了十多秒,$92$分<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, n, a[maxk], i, t;</span><br><span class="line">priority_queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; q;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    q.push(<span class="number">1</span>); s.insert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt;= n) &#123;</span><br><span class="line">        t = q.top(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> num = t * a[j];</span><br><span class="line">            <span class="keyword">if</span> (!s.count(num)) &#123;</span><br><span class="line">                s.insert(num);</span><br><span class="line">                q.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 92points TLE with O2 */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="100-分循环做法"><a href="#100-分循环做法" class="headerlink" title="$100$分循环做法"></a>$100$分循环做法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由题可知,当前产生的第$i$个丑数$s[i]$,是之前的某个丑数$\times a[j]$<br>某个丑数$\times a[j]$需要大于$s[i-1]$,而且要尽可能的小<br>于是我们可以枚举$j$,然后找到最小的一个丑数$minn$使$minn\times a[j]&gt;s[i-1]$</p>
<p><strong>但是..三重循环可能还会$TLE$</strong></p>
<p>很容易发现满足条件的丑数$x\times a[j]&gt;s[i-1]$,一定满足条件$x\times a[j]&gt;s[i-2]$<br>于是我们就可以从满足$x\times a[j]&gt;s[i-2]$的丑数$x$的位置往后枚举,找到满足条件$x\times a[j]&gt;s[i-1]$的丑数<br>代码里$b[j]$表示$a[j]$至少与第几小丑数相乘才能得到一个比$s[i-1]$大的丑数</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, n, a[maxk], i, t, s[maxn], b[maxk];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> minn = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">61</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[j] * s[b[j]] &lt;= s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                b[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[j] * s[b[j]] &lt; minn) &#123;</span><br><span class="line">                minn = a[j] * s[b[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = minn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, s[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 101ms 1584kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="mathcal-「P1631」-序列合并"><a href="#mathcal-「P1631」-序列合并" class="headerlink" title="$\mathcal{「P1631」}$ 序列合并"></a>$\mathcal{「P1631」}$ <a href="https://www.luogu.org/problemnew/show/P1631" target="_blank" rel="noopener">序列合并</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>参考<a href="https://www.luogu.org/blog/user23845/solution-p1631" target="_blank" rel="noopener">Red_w1nE</a></p>
<p>把$A$和$B$两个序列分别从小到大排序<br>这样,从$A$和$B$中各任取一个数相加得到$n^2$个和,可以把这些和看成形成了$n$个队列:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] + b[<span class="number">1</span>] &lt;= a[<span class="number">1</span>] + b[<span class="number">2</span>] &lt;= ... &lt;= a[<span class="number">1</span>] + B[n]</span><br><span class="line">a[<span class="number">2</span>] + b[<span class="number">1</span>] &lt;= a[<span class="number">2</span>] + b[<span class="number">2</span>] &lt;= ... &lt;= a[<span class="number">2</span>] + B[n]</span><br><span class="line">    ...            ...        ...        ...</span><br><span class="line">a[n] + b[<span class="number">1</span>] &lt;= a[n] + b[<span class="number">2</span>] &lt;= ... &lt;= a[n] + B[n]</span><br></pre></td></tr></table></figure></p>
<p>接下来,将这$n$个队列进行合并:</p>
<ul>
<li>将这$n$个队列中的第一个元素放入优先队列中；</li>
<li>每次取出优先队列中的最小值,若这个最小值来自于第$k$个队列,那么,就将第$k$个队列的下一个元素放入优先队列中。<br>我们可以使用一个结构体来记录队列中一个节点的值<code>val</code>,队列号<code>id</code>,下一个元素<code>nxt</code></li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id, nxt;</span><br><span class="line">    Node(<span class="keyword">int</span> v, <span class="keyword">int</span> i, <span class="keyword">int</span> n): val(v), id(i), nxt(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], b[maxn];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        q.push(Node( a[i] + b[<span class="number">0</span>], i, <span class="number">1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Node t = q.top(); q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, t.val);</span><br><span class="line">        q.push(Node( a[t.id] + b[t.nxt], t.id, t.nxt + <span class="number">1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 402ms 3196kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="mathcal-「P2850」-虫洞"><a href="#mathcal-「P2850」-虫洞" class="headerlink" title="$\mathcal{「P2850」}$ 虫洞"></a>$\mathcal{「P2850」}$ <a href="https://www.luogu.org/problemnew/show/P2850" target="_blank" rel="noopener">虫洞</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>判断<strong><em>负环</em></strong>的模板题</p>
<p>每条小路连接边权为正的无向边,每个虫洞连接边权为负的无向边<br>存在负环,则可以回到过去<br>使用$SPFA$算法判断负环($Floyd$也可以,但不开O2优化会$TLE$)</p>
<p>$SPFA$判断负环:<strong>如果任意一条边被修改大于$n$次,这个图内一定存在至少一个负环</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>使用<code>vector</code>建边,邻接表也可以<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w): from(u), to(v), val(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(u, v, w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[u].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[maxn], vis[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    dist[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (dist[e.to] &gt; dist[u] + e.val) &#123;</span><br><span class="line">                dist[e.to] = dist[u] + e.val;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    q.push(e.to);</span><br><span class="line">                    cnt[e.to]++;  <span class="comment">//统计修改次数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[e.to] &gt; n) &#123; <span class="comment">//修改大于n次</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">//存在负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn - <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        clear();</span><br><span class="line">        n = read(); m = read(); w = read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = read(), v = read(), d = read();</span><br><span class="line">            add(u, v, d); add(v, u, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = read(), v = read(), d = read();</span><br><span class="line">            add(u, v, -d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (SPFA(<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 164ms 1024kB */</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P5020 P1621 P4942」小练习-题解</title>
    <url>/p/eb0c7a6c.html</url>
    <content><![CDATA[<h2 id="mathcal-「P5020」-货币系统"><a href="#mathcal-「P5020」-货币系统" class="headerlink" title="$\mathcal{「P5020」}$ 货币系统"></a>$\mathcal{「P5020」}$ <a href="https://www.luogu.org/problemnew/show/P5020" target="_blank" rel="noopener">货币系统</a></h2><p>表面上是数论，其实就是个<strong><em>动态规划</em></strong></p>
<p>首先设$A = (n, a) \ \ B = (m, b)$<br>可以证明$B \subseteq A$<br>$proof:$<br>    我们设$x\in A$且$x$不能被$A$集合内除它以外的元素组成。<br>    然后我们假设$x \notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。<br>    那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。<br>    综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内<br>$Q.E.D$</p>
<p>然后动态规划<br><code>dp[i]</code>表示$i$面值最多能被几张钱表示<br>则若其不能被表示<code>dp[i] = -inf</code><br>能表示且只有它自己则<code>dp[i] = 1</code><br>初始化<code>dp[] = -inf; dp[0] = 0</code><br>状态转移方程为<code>dp[j] = max(dp[j], dp[j - a[i]] + 1)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, ans, a[<span class="number">1010</span>], dp[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        ans = <span class="number">0</span>; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= <span class="number">25010</span>; ++j) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - a[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[a[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 862ms 944kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="mathcal-「P1621」-集合"><a href="#mathcal-「P1621」-集合" class="headerlink" title="$\mathcal{「P1621」}$ 集合"></a>$\mathcal{「P1621」}$ <a href="https://www.luogu.org/problemnew/show/P1621" target="_blank" rel="noopener">集合</a></h2><p>使用<strong><em>并查集</em></strong>和<strong><em>埃氏筛法</em></strong>(埃拉托斯特尼筛法)即可<br>具体操作是边筛边合并集合</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ufs[maxn], a, b, p, ans;</span><br><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ufs[x] == x ? x : ufs[x] = find(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    ans = b - a + <span class="number">1</span>;               <span class="comment">//初始个数为区间内数的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= b; ++i) &#123; <span class="comment">//初始化</span></span><br><span class="line">        ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= b; ++i) &#123; <span class="comment">//埃氏筛</span></span><br><span class="line">        <span class="keyword">if</span> (!isprime[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p) &#123;          <span class="comment">//大于p才合并</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= b; j += i) &#123;</span><br><span class="line">                    isprime[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &gt;= a &amp;&amp; find(j) != find(j - i)) &#123; <span class="comment">//合并</span></span><br><span class="line">                        ufs[find(j)] = find(j - i);</span><br><span class="line">                        --ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;               <span class="comment">//不大于p但要标记</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= b; j += i) &#123;</span><br><span class="line">                    isprime[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 38ms 1312kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="mathcal-「P4942」-小凯的数字"><a href="#mathcal-「P4942」-小凯的数字" class="headerlink" title="$\mathcal{「P4942」}$ 小凯的数字"></a>$\mathcal{「P4942」}$ <a href="https://www.luogu.org/problemnew/show/P4942" target="_blank" rel="noopener">小凯的数字</a></h2><p>类似于$NOIp2017\ D1T1$ <a href="https://www.luogu.org/problemnew/show/P3951" target="_blank" rel="noopener">小凯的疑惑</a>,推柿子即可</p>
<p>首先$l(l+1)(l+2)…(r-1)r$可以表示为$l\times 10^? + (l + 1)\times 10^? + … + r\times 10^?$<br>同时我们知道$10$的若干次方除以$9$的余数<strong>恒为</strong>$1$<br>所以$l(l+1)(l+2)…(r-1)r$除以$9$的余数就等于$l + (l + 1) + … + (r - 1) + r$的余数<br>并且$l,l+1,…,r$为等差数列,公差为$1$<br>运用等差数列求和公式即可求解</p>
<p>$a_1 = l\ d = 1$<br>$n = r - l + 1$<br>$S_n = n\times a_1 + n\times (n - 1)\times \frac{d}{2}$<br>所以<br>$$<br>\boxed{Ans = n\times l + n\times (n - 1) \div 2}<br>$$</p>
<p>另外要边算边取模,除以$2$要变成乘模$9$下的逆元$5$<br>所以公式如下<br><code>ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l, r, n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;l, &amp;r);</span><br><span class="line">        n = (r - l + <span class="number">1</span>) % <span class="number">9</span>;</span><br><span class="line">        ans = (n * (l % <span class="number">9</span>) % <span class="number">9</span> + n * (n - <span class="number">1</span>) % <span class="number">9</span> * <span class="number">5</span> % <span class="number">9</span>) % <span class="number">9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 32ms 888kB */</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2016」题解</title>
    <url>/p/2a6e5fce.html</url>
    <content><![CDATA[<p>$???$就一道紫题$???$,还是$D1T2\ ???$</p>
<a id="more"></a>
<h2 id="D1T1-玩具迷题"><a href="#D1T1-玩具迷题" class="headerlink" title="$D1T1$ 玩具迷题"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P1563" target="_blank" rel="noopener">玩具迷题</a></h2><p>简单的<strong><em>模拟</em></strong>,没的说</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> towards;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125; a[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ai, si;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].towards &gt;&gt; a[i].name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> peo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ai &gt;&gt; si;</span><br><span class="line">        <span class="keyword">if</span> (ai == <span class="number">0</span> &amp;&amp; a[peo].towards == <span class="number">0</span>) peo = (peo + n - si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">0</span> &amp;&amp; a[peo].towards == <span class="number">1</span>) peo = (peo + si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">1</span> &amp;&amp; a[peo].towards == <span class="number">0</span>) peo = (peo + si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">1</span> &amp;&amp; a[peo].towards == <span class="number">1</span>) peo = (peo + n - si) % n;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[peo].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* 430ms 4760kB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1993」小K的农场-题解 &amp; 差分约束系统</title>
    <url>/p/6dcf876e.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problem/P1993" target="_blank" rel="noopener">「Luogu P1993」小K的农场</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$m$个约束条件,$n$个农场<br>有三种条件,其中$a,b$表示编号为$a,b$的农场的植物个数</p>
<ol>
<li>$a-b≥c$</li>
<li>$a-b≤c$</li>
<li>$a=b$<br>求是否存在一种方案,使农场中的植物数满足约束要求</li>
</ol>
<h3 id="I-差分约束系统"><a href="#I-差分约束系统" class="headerlink" title="$I.$ 差分约束系统"></a>$I.$ 差分约束系统</h3><p>以第$1$种约束为例:<br>$$a-b\ge c\Rightarrow b\le a+(-c)$$<br>与求最短路径中的三角形不等式$dis[e.to]\le dis[u] + e.val$类似<br>所以我们对于约束条件$a-b\ge c$,从$a$到$b$建一条边权为$-c$的边<br>同理三种约束条件依次为</p>
<ol>
<li>$a-b\ge c$, 从$a$到$b$建$-c$单向边</li>
<li>$a-b\le c$, 从$b$到$a$建$c$单向边</li>
<li>$a=b$, 从$a$到$b$建权值为$0$的双向边</li>
</ol>
<p>如果存在一组解${x_1, x_2, \ldots, x_n}$,则对任意常数$\Delta$, ${x_1+\Delta, x_2+\Delta, \ldots, x_n+\Delta}$也是一组解<br>不妨先求一组负数解,于是就有了条件$x_i-x_0\le 0$<br>即,从$0$向所有节点建一条边权为$0$的单向边</p>
<p>求解时,设$\mathtt{dis[0]=0}$,然后以$0$为源点求单源最短路<br>如果存在负环,则系统无解<br>不存在负环,则$\mathtt{dis[i]}$为系统的一组解</p>
<h3 id="II-负环"><a href="#II-负环" class="headerlink" title="$II.$ 负环"></a>$II.$ 负环</h3><p>如果任意一条边被修改大于$n$次(执行$n$次松弛操作),这个图内一定存在至少一个负环<br>我们可以使用一个数组$cnt$来记录每条边执行松弛操作的次数<br>当向队列中添加节点$\mathtt{e.to}$时,$\mathtt{cnt[e.to]++}$<br>然后再判断$\mathtt{cnt[e.to]&gt;n}$,如果返回$\mathtt{true}$则存在负环</p>
<h3 id="III-SPFA-的-SLF-优化"><a href="#III-SPFA-的-SLF-优化" class="headerlink" title="$III.$ $SPFA$的$SLF$优化"></a>$III.$ $SPFA$的$SLF$优化</h3><p>本题如果直接跑$SPFA$的话,会$TLE\ 3$个点,即使手动开了$O3$优化,还是会$TLE\ 1$个点<br>所以我们可以使用$SLF(Small\ Label\ First)$优化</p>
<p>$SLF:$<br>当加入一个新节点$v$的时候</p>
<ul>
<li>如果此时的$\mathtt{dis[v]}$比队首$\mathtt{dis[q.front()]}$小的话，就把$v$点加入到队首</li>
<li>否则把他加入到队尾</li>
</ul>
<p>因为先扩展最小的点可以尽量使程序尽早的结束</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w): from(u), to(v), val(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(u, v, w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[u].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn], vis[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_back(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(); vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (dis[e.to] &gt; dis[u] + e.val) &#123;</span><br><span class="line">                dis[e.to] = dis[u] + e.val;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!q.empty() &amp;&amp; dis[e.to] &lt; dis[q.front()]) &#123;</span><br><span class="line">                        q.push_front(e.to);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q.push_back(e.to);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt[e.to]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[e.to] &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = read(), b = read(), c = read();</span><br><span class="line">            add(a, b, -c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = read(), b = read(), c = read();</span><br><span class="line">            add(b, a, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = read(), b = read();</span><br><span class="line">            add(a, b, <span class="number">0</span>); add(b, a, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        add(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(SPFA(<span class="number">0</span>) ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1.94s 1.61MB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」左偏树(可并堆)</title>
    <url>/p/7ab0d731.html</url>
    <content><![CDATA[<p>左偏树($Leftist\ Tree$)，是一种 <strong>可以合并的堆状结构</strong>，支持以下操作</p>
<a id="more"></a>
<ul>
<li>$Pop\ x$，删除节点$x$</li>
<li>$Merge\ x\ y$，合并两棵左偏树</li>
</ul>
<p>对于一个左偏树的节点，需要维护以下值</p>
<ul>
<li>$dist$，记录这个节点到它子树里面最近的叶子节点的距离</li>
<li>$value$，每个节点包含的值</li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>一个节点的$value$大于(或小于)左右孩子的$value$<strong><em>(堆性质)</em></strong> </li>
<li>一个节点的左孩子的$dist$不小于右孩子的$dist$<strong><em>(左偏性质)</em></strong></li>
<li>一个节点的距离始终等于右孩子+1</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Merge-操作"><a href="#Merge-操作" class="headerlink" title="$Merge$操作"></a>$Merge$操作</h3><p>首先我们设两个节点$x,y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了</p>
<p>合并了$x$的右子树和$y$后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护左偏性质，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x=dist_{rson(x)}+1$</p>
<h3 id="Pop-操作"><a href="#Pop-操作" class="headerlink" title="$Pop$操作"></a>$Pop$操作</h3><p>略$…$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LeftistTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LeftistTreeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> dis, val, rt;</span><br><span class="line">        <span class="keyword">int</span> ls, rs;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ls(x)  tree[x].ls</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rs(x)  tree[x].rs</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> dis(x) tree[x].dis</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> val(x) tree[x].val</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rt(x)  tree[x].rt</span></span><br><span class="line">    &#125;tree[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (val(x) &gt; val(y) || (val(x) == val(y) &amp;&amp; x &gt; y)) &#123;</span><br><span class="line">            swap(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        rs(x) = merge(rs(x), y);</span><br><span class="line">        <span class="keyword">if</span> (dis(ls(x)) &lt; dis(rs(x))) swap(ls(x), rs(x));</span><br><span class="line">        rt(ls(x)) = rt(rs(x)) = rt(x) = x;</span><br><span class="line">        dis(x) = dis(rs(x)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> rt(x) == x ? x : rt(x) = get(rt(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        val(x) = <span class="number">-1</span>;</span><br><span class="line">        rt(ls(x)) = ls(x); rt(rs(x)) = rs(x);</span><br><span class="line">        rt(x) = merge(ls(x), rs(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dis(<span class="number">0</span>) = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            rt(i) = i;</span><br><span class="line">            val(i) = read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SolveMerge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val(x) == <span class="number">-1</span> || val(y) == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> fx = get(x), fy = get(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            rt(fx) = rt(fy) = merge(fx, fy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SolvePop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val(x) == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, val(get(x))), pop(get(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3377" target="_blank" rel="noopener">Luogu P3377 左偏树(可并堆)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」并查集</title>
    <url>/p/9c4b8ceb.html</url>
    <content><![CDATA[<p>并查集($union-find\ \ set$)是一种可以<strong>动态维护</strong>若干个不重叠的<strong>集合</strong>，并支持<strong>合并与查询</strong>的数据结构，支持以下两种基本操作：</p>
<a id="more"></a>
<ul>
<li>$Find$，查询一个元素属于哪个集合(即查找根)</li>
<li>$Union$，把两个集合合并成一个集合</li>
</ul>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>我们可以使用树形结构存储集合，树上每个点表示一个元素，树根可以代表这个集合</p>
<p>使用一个数组<code>ufs[]</code>来保存每个节点的父亲节点</p>
<p>则合并$x,y$所在的集合可以表示为$ufs[root_x]=root_y$</p>
<p>查找根节点可以一直沿着数组向上查找</p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>防止整棵树的链非常长，导致每次查询时间复杂度极高，可以在<strong>每次执行$Find$操作时，把访问的节点指向根节点</strong>，这种方法称为<strong><em>路径压缩</em></strong>，$Find$操作的时间复杂度为$O(log_2n)$</p>
<p>$Code\ Below:$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，每个点独立(自己是自己的根)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ufs[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ufs[x] ? x : ufs[x] = find(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//union操作(注意union是C++关键字)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ufs[get(x)] = get(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>有时，需要维护的每个节点到根节点的边权值，可以增加一个数组<code>d[]</code>来保存权值，对于两个操作也有所更改</p>
<p>再增加一个数组<code>size[]</code>记录每个树根上集合大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ufs[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> fx = find(ufs[x]);</span><br><span class="line">    d[x] += d[ufs[x]];</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = fx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//union</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">    ufs[fx] = fy; d[fx] = size[fy];</span><br><span class="line">    size[fy] += size[fx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可撤销并查集"><a href="#可撤销并查集" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h2><p>可能需要维护一个并查集并要求可以<strong>撤销</strong>两节点的连接关系</p>
<p>我们可以对每个操作$(u, v)$执行前，把节点$u$换为树根(<del>不难发现</del>，$ufs[]$变化的只有从$u$到原节点的一条链上)</p>
<p>然后对于操作</p>
<ul>
<li>$Connect\ u\ v$，需要把$u$的父亲节点设为$v$</li>
<li>$Delete\ u\ v$，可以把$v$的父亲节点设为$0$</li>
<li>$Query\ u\ v$，直接暴力搜索$v$所在的链即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFindSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ufs[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ufs[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">//换u为根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, fa = ufs[u]; u; fa = ufs[u]) &#123;</span><br><span class="line">            ufs[u] = i; i = u; u = fa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ufs[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteuv</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ufs[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; v != u &amp;&amp; v; v = ufs[v]);</span><br><span class="line">        <span class="built_in">puts</span>(v == u ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3367" target="_blank" rel="noopener">Luogu P3367 并查集 (普通并查集)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P1196" target="_blank" rel="noopener">Luogu P1196 银河英雄传说 (带权并查集)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P2147" target="_blank" rel="noopener">Luogu P2147 洞穴勘探 (可撤销并查集)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>「图论算法」树上并查集 dsu on tree</title>
    <url>/p/da7e0a9d.html</url>
    <content><![CDATA[<p>$dsu\ on\ tree$($disjoint\ set\ union\ \text{on tree}$)算法，也称 <strong>树上并查集</strong>。使用了并查集的<em>按秩合并</em>(<strong>启发式合并</strong>)的方法，结合 <em>树链剖分</em> 中的 <strong>轻重儿子划分</strong> ，对 <strong>树上暴力统计</strong> 进行了优化。使用这个算法需要满足以下两个条件：</p>
<a id="more"></a>
<ul>
<li>每次只对子树进行查询</li>
<li>过程中没有对树的修改</li>
</ul>
<p>可以将$O(n^2)$的暴力操作优化到$O(n\log_2n)$</p>
<h2 id="pre-树链剖分-轻重链划分"><a href="#pre-树链剖分-轻重链划分" class="headerlink" title="$pre.\ $树链剖分 - 轻重链划分"></a>$pre.\ $树链剖分 - 轻重链划分</h2><p>在$dsu\ on\ tree$算法中，只需要统计出每个节点的<em>轻重儿子</em>，而不需要划分轻重链，所以我们只需要树链剖分中的$\texttt{dfs1()}$，并且只保留和轻重儿子有关的操作即可</p>
<blockquote>
<p>关于 <strong>轻重儿子</strong> ：</p>
<ul>
<li>一个节点的所有子节点中，子树所含节点个数最多的子节点称为 <strong>重儿子</strong></li>
<li>除重儿子外，一个节点的其余儿子均为 <strong>轻儿子</strong></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>; <span class="comment">// 以x为根的子树大小初始化为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(e.to, x);</span><br><span class="line">        siz[x] += siz[e.to]; <span class="comment">// 加上子节点的大小</span></span><br><span class="line">        <span class="keyword">if</span> (siz[e.to] &gt; siz[son[x]]) &#123;</span><br><span class="line">            son[x] = e.to; <span class="comment">// 更新重儿子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-算法流程"><a href="#I-算法流程" class="headerlink" title="$I.\ $算法流程"></a>$I.\ $算法流程</h2><p>对于每一个节点$x$:</p>
<ul>
<li>遍历所有子节点<ul>
<li>递归计算所有轻儿子的子树，并删除其对答案的贡献</li>
</ul>
</li>
<li>递归计算重儿子，保留对答案的贡献</li>
<li>统计所有轻儿子对答案的贡献</li>
<li>更新节点答案</li>
</ul>
<p>伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (all edge from x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(e.to, x, <span class="number">0</span>); <span class="comment">// 暴力统计轻儿子的子树的贡献，并删除(opt=0)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) dfs(son[x], x, <span class="number">1</span>); <span class="comment">// 统计重儿子的贡献，不删除</span></span><br><span class="line">    upd(x); <span class="comment">// 暴力统计该节点所有轻儿子的贡献</span></span><br><span class="line">    ans[x] = now; <span class="comment">// 更新答案</span></span><br><span class="line">    <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">        del(x); <span class="comment">// 删除需要删除的贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    solve(x); <span class="comment">// 计算当前答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == Son) <span class="keyword">continue</span>;</span><br><span class="line">        upd(e.to, x, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于暴力统计的只是轻儿子，而每个节点的轻儿子不超过$\log_2n$个，所以整个算法复杂度保证在了$O(n\log_2n)$</p>
<h2 id="II-模板题"><a href="#II-模板题" class="headerlink" title="$II.\ $模板题"></a>$II.\ $模板题</h2><p><a href="https://www.luogu.org/problemnew/solution/CF600E" target="_blank" rel="noopener">$CodeForces\ 600E\ \ Lomsat\ gelral$</a> </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v): from(u), to(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(u, v));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[u].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Mx, Son, col[maxn], son[maxn], siz[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(e.to, x);</span><br><span class="line">        siz[x] += siz[e.to];</span><br><span class="line">        <span class="keyword">if</span> (siz[e.to] &gt; siz[son[x]]) &#123;</span><br><span class="line">            son[x] = e.to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cnt[col[x]] += val;</span><br><span class="line">    <span class="keyword">if</span> (cnt[col[x]] &gt; Mx) &#123;</span><br><span class="line">        Mx = cnt[col[x]];</span><br><span class="line">        sum = col[x];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[col[x]] == Mx) &#123;</span><br><span class="line">        sum += (<span class="keyword">long</span> <span class="keyword">long</span>)col[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == Son) <span class="keyword">continue</span>;</span><br><span class="line">        Add(e.to, x, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.to != son[x]) dfs2(e.to, x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">        dfs2(son[x], x, <span class="number">1</span>);</span><br><span class="line">        Son = son[x];</span><br><span class="line">    &#125;</span><br><span class="line">    Add(x, fa, <span class="number">1</span>); Son = <span class="number">0</span>;</span><br><span class="line">    ans[x] = sum;</span><br><span class="line">    <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">        Add(x, fa, <span class="number">-1</span>);</span><br><span class="line">        sum = <span class="number">0</span>, Mx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        col[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        add(u, v); add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>图论</tag>
        <tag>dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」树状数组</title>
    <url>/p/8c13697e.html</url>
    <content><![CDATA[<p>树状数组($Binary\ Indexed\ Trees$)是一个维护<strong>前缀和</strong>的数据结构，需要支持以下操作</p>
<a id="more"></a>
<ul>
<li>$Add\ x\ y$，单点增加，<code>a[x] += y</code></li>
<li>$Query\ x$，查询前缀和</li>
</ul>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="lowbit-运算"><a href="#lowbit-运算" class="headerlink" title="$lowbit$运算"></a>$lowbit$运算</h3><p>$lowbit(n)$表示非负整数$n$在二进制表示下<strong>最低位的1及其后边所有的0构成的数值</strong></p>
<p>为了实现$lowbit$运算，先把$n$取反，此时第$k$位变为$0$(设第$k$位是$1$，其后均为$0$)，第$0\sim k-1$位变为$1$，再整体加一，所以第$k$位变为$1$，其后为$0$，其前每位恰好与原数相反，再按位求与($\&amp;$)即可得到。由于在补码下，$\sim n=-1-n$，所以</p>
<p>$$lowbit(n)=n\ \&amp;\  (\sim n+1)=n\ \&amp;\ -n$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &amp; -n; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>对于一个原序列$a[]$，可以建立一个数组$tree[]$，来保存$a$的区间$[x-lowbit(x)+1, x]$内值的和，即</p>
<p>$$tree[x] = \sum_{i=x-lowbit(x)+1}^x{a[i]}$$</p>
<p>同时$tree$数组可以看成一个树形结构，并满足以下性质</p>
<ul>
<li>每个节点$tree[x]$保存以$x$为根的子树中所有叶节点的和</li>
<li>每个节点$tree[x]$的子节点个数等于$lowbit(x)$的位数</li>
<li>除树根外，每个节点$tree[x]$的父亲节点为$tree[x+lowbit(x)]$</li>
<li>树的深度为$\log_2n$</li>
</ul>
<p>根据这些性质，就<del>很容易地</del>写出代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tree[maxn], n, m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> k &amp; -k; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; x &lt;= maxn; x += x &amp; -x) tree[x] += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= x &amp; -x) ans += tree[x];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			add(i, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上，树状数组可以嵌套维护，来解决更多问题，例如区间修改</p>
<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3374" target="_blank" rel="noopener">Luogu P3374 树状数组1 (单点修改，区间查询)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3368" target="_blank" rel="noopener">Luogu P3368 树状数组2 (区间修改，单点查询)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3372" target="_blank" rel="noopener">Luogu P3372 线段树1 (区间修改，区间查询)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」分配问题-题解</title>
    <url>/p/11b1dcbd.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4014" target="_blank" rel="noopener">「Luogu P4014」分配问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$件工作要分配给$n$个人做<br>给出每个人做每个工件的效益$c_{i,j}$</p>
<p>求最小效益和最大效益</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的最小/大费用最大流<br>将所有人和所有工作各分为一个点集</p>
<ol>
<li>从 源点 向 所有人 建一条 <strong>容量为$1$,费用为$0$</strong> 的边(只能选一次,且对答案无贡献)</li>
<li>从 所有工作 向 汇点 建一条 <strong>容量为$1$,费用为$0$</strong> 的边(只能做一次,且对答案无贡献)</li>
<li>从 每个人 向 所有工作 建一条 <strong>容量为$1$,费用为对应效益</strong> 的边(只能做一种工作,且对答案工作为对应效益)</li>
</ol>
<p>求出最小费用最大流和最大费用最大流</p>
<p>两个问之间要清空图并重建(因为求最大流过程中会修改flow)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.size();</span><br><span class="line">	G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">0</span>) <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]]; <span class="keyword">bool</span> judge;</span><br><span class="line">            <span class="keyword">if</span> (opt) judge = d[e.to] &lt; d[x] + e.cost;</span><br><span class="line">            <span class="keyword">else</span> judge = d[e.to] &gt; d[x] + e.cost;</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; judge) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.push(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!opt &amp;&amp; d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt &amp;&amp; d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost, <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); s = <span class="number">0</span>; t = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = read(); tmp[i][j] = c;</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        add(s, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        add(i + n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MinCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line"></span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            add(i, j + n, <span class="number">1</span>, tmp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        add(s, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        add(i + n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」圆桌问题-题解</title>
    <url>/p/25e68a12.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3254" target="_blank" rel="noopener">「Luogu P3254」圆桌问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$m$个单位,$n$个餐桌<br>第$i$个单位的代表人数$r_i$, 第$i$张餐桌能容纳的人数$c_i$<br>同一个单位的代表不能在同一个餐桌</p>
<p>若有一种方案,输出$1$,并输出方案<br>若没有方案,输出$0$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>二分图,左点集为单位,右点集为餐桌,求其 <strong>最大匹配</strong></p>
<ol>
<li>对于每个单位,从 这个点 向 所有餐桌 接一条 <strong>容量为1</strong> 的边(即每个餐桌只能容纳同一个单位的一个人)</li>
<li>从 源点 向 每个单位 接一条 <strong>容量为单位人数</strong> 的边(即每个单位所有人都要参加)</li>
<li>从 每个餐桌 向 汇点 接一条 <strong>容量为餐桌人数</strong> 的边</li>
</ol>
<p>如果最大流和所有单位总人数相等,则有可行方案<br>对于每个单位,输出出边满足$\mathtt{e.cap == e.flow}$的$\mathtt{e.to-m}$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">450</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.push_back((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += DFS(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = read(); n = read();</span><br><span class="line">    s = <span class="number">0</span>; t = m + n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            add(i, j + m, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = read(); tot += r;</span><br><span class="line">        add(s, i, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = read();</span><br><span class="line">        add(i + m, t, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = dinic(s, t);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == tot) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; ++u) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.to != s &amp;&amp; e.cap == e.flow) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>, e.to - m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」线段树</title>
    <url>/p/d1cf0d36.html</url>
    <content><![CDATA[<p>线段树($Segment\ Tree$)是一种基于分治思想的<strong>二叉树</strong>形数据结构，可以用于<strong>区间</strong>上的数据维护，它可以维护以下值</p>
<a id="more"></a>
<ul>
<li>$maxn\ minn$，区间上最大最小值</li>
<li>$sum$，区间和</li>
<li>$lmax$，每段上最大前缀和</li>
<li>$rmax$，每段上最大后缀和</li>
<li>$……$</li>
</ul>
<p>和以下操作</p>
<ul>
<li>$Add\ x\ y\ k$，把区间$[x,y]$内元素值全加$k$</li>
<li>$Query\ x\ y$，查询区间$[x,y]$内的某个值</li>
</ul>
<p>由于线段树会维护一种数据，其他也很好写，所以本篇以<strong>区间和</strong>为例</p>
<h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><p>在每次$Add$操作中，如果将相关区间的值全部更新，则会把时间复杂度提高到$O(n)$</p>
<p>所以我们可以采取一种<strong><em>延迟标记</em></strong>($lazy-tag$)的技巧，如果被标记，则说明本区间内的值被整体加上某个值了</p>
<p>详细方法见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SegmentTreeNode</span> &#123;</span> <span class="comment">//树上的节点</span></span><br><span class="line">        <span class="keyword">int</span> l, r;                   <span class="comment">//节点表示区间的左右端点</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum, add;         <span class="comment">//区间和和add的延迟标记</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l      <span class="comment">//方便访问</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> add(x) tree[x].add</span></span><br><span class="line">    &#125; tree[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> a[maxn], n, m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//建树</span></span><br><span class="line">        l(p) = l, r(p) = r;           <span class="comment">//设置左右端点</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; sum(p) = a[l]; <span class="keyword">return</span>; &#125; <span class="comment">//到达叶子节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(p * <span class="number">2</span>, l, mid);         <span class="comment">//递归构建左右树</span></span><br><span class="line">        build(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        sum(p) = sum(p * <span class="number">2</span>) + sum(p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">//更新数据，可改为需要维护的多个值的维护方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">//下传延迟标记</span></span><br><span class="line">        <span class="keyword">if</span> (add(p)) &#123; <span class="comment">//如果有标记</span></span><br><span class="line">            sum(p * <span class="number">2</span>) += add(p) * (r(p * <span class="number">2</span>) - l(p * <span class="number">2</span>) + <span class="number">1</span>); <span class="comment">//sum传至左儿子</span></span><br><span class="line">            sum(p * <span class="number">2</span> + <span class="number">1</span>) += add(p) * (r(p * <span class="number">2</span> + <span class="number">1</span>) - l(p * <span class="number">2</span> + <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">//右儿子</span></span><br><span class="line">            add(p * <span class="number">2</span>) += add(p);      <span class="comment">//延迟标记传至左儿子</span></span><br><span class="line">            add(p * <span class="number">2</span> + <span class="number">1</span>) += add(p);  <span class="comment">//右儿子</span></span><br><span class="line">            add(p) = <span class="number">0</span>; <span class="comment">//本节点延迟标记清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123; <span class="comment">//更新区间内值</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) &#123; <span class="comment">//完全覆盖</span></span><br><span class="line">            sum(p) += (<span class="keyword">long</span> <span class="keyword">long</span>)d * (r(p) - l(p) + <span class="number">1</span>); <span class="comment">//更新节点信息</span></span><br><span class="line">            add(p) += d; <span class="comment">//打上延迟标记</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(p); <span class="comment">//下传标记</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l(p) + r(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) update(p * <span class="number">2</span>, l, r, d);      <span class="comment">//递归更新左右</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;  mid) update(p * <span class="number">2</span> + <span class="number">1</span>, l, r, d);</span><br><span class="line">        sum(p) = sum(p * <span class="number">2</span>) + sum(p * <span class="number">2</span> + <span class="number">1</span>);      <span class="comment">//维护数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//查询操作</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) <span class="keyword">return</span> sum(p); <span class="comment">//完全覆盖</span></span><br><span class="line">        pushdown(p); <span class="comment">//下传标记</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l(p) + r(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) ans += query(p * <span class="number">2</span>, l, r);     <span class="comment">//加上左右部分值</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;  mid) ans += query(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> add   <span class="comment">//防止后续使用add等出现错误</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> r</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了使代码简洁，还可以宏定义一些名称</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lt p&lt;&lt;1     <span class="comment">//左孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rt p&lt;&lt;1|1   <span class="comment">//右孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lt,l,mid    <span class="comment">//左子树</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt,mid+1,r  <span class="comment">//右子树</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3372" target="_blank" rel="noopener">Luogu P3372 线段树1 (区间增加，区间查询和)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3373" target="_blank" rel="noopener">Luogu P3373 线段树2 (区间增加，区间乘数，区间查询和)</a></p>
<p>$SPOJ$的$GSS$系列</p>
<ol>
<li><a href="https://www.luogu.org/problemnew/show/SP1043" target="_blank" rel="noopener">SP1043 GSS1 - Can you answer these queries I</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP1557" target="_blank" rel="noopener">SP1557 GSS2 - Can you answer these queries II</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP1716" target="_blank" rel="noopener">SP1716 GSS3 - Can you answer these queries III</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP2713" target="_blank" rel="noopener">SP2713 GSS4 - Can you answer these queries IV</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP2916" target="_blank" rel="noopener">SP2916 GSS5 - Can you answer these queries V</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP4487" target="_blank" rel="noopener">SP4487 GSS6 - Can you answer these queries VI</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP6779" target="_blank" rel="noopener">SP6779 GSS7 - Can you answer these queries VII</a></li>
</ol>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2017」题解</title>
    <url>/p/c5ac34f0.html</url>
    <content><![CDATA[<pre><code>NOIp2017的题比NOIp2018的题好做一点
</code></pre><a id="more"></a>
<h2 id="D1T1-小凯的疑惑"><a href="#D1T1-小凯的疑惑" class="headerlink" title="$D1T1$ 小凯的疑惑"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P3951" target="_blank" rel="noopener">小凯的疑惑</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>推柿子(<del>正确性未知</del>)<br>设$a &lt; b$ 答案为$x$<br>所以:<br>$$x \equiv ma \pmod b (1 \leq m \leq b - 1)$$<br>即$x = ma + nb (1 \leq m \leq b - 1)$<br>显然当$ n \geq 0$时 $x$可以用$a, b$表示出来，不合题意<br>因此当$n = -1$时$x$取得最大值，此时$x = ma - b$<br>显然当$m$取得最大值$b - 1$时$x$最大，此时$x = (b - 1)a - b = ab - a - b$<br>因此$a, b$所表示不出的最大的数是<br>$$\boxed{ab - a - b}$$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a * b - a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 60ms 948kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D1T2-时间复杂度"><a href="#D1T2-时间复杂度" class="headerlink" title="$D1T2$ 时间复杂度"></a>$D1T2$ <a href="https://www.luogu.org/problemnew/show/P3952" target="_blank" rel="noopener">时间复杂度</a></h2><p><del>毒瘤</del>大模拟<br>没什么好说的,直接上代码</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str1, str2;      </span><br><span class="line"><span class="keyword">int</span> cal, O, NumOfLoop, vis[<span class="number">27</span>], var[<span class="number">27</span>], Onow, Kill, AddO[<span class="number">100</span>], Omax, WhereKill, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T--;</span><br><span class="line">        cal = <span class="number">0</span>; O = <span class="number">0</span>; Omax = <span class="number">0</span>; WhereKill = <span class="number">0</span>; NumOfLoop = <span class="number">0</span>; Onow = <span class="number">0</span>; Kill = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(AddO, <span class="number">0</span>, <span class="keyword">sizeof</span>(AddO));</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            str1 = str2;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str2;</span><br><span class="line">        &#125; <span class="keyword">while</span>(str2[<span class="number">0</span>] != <span class="string">'O'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++) cal = cal * <span class="number">10</span> + str1[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; str2.length() - <span class="number">1</span>; i++) O = O * <span class="number">10</span> + str2[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">while</span> (cal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cal--;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">            <span class="keyword">if</span> (str1[<span class="number">0</span>] == <span class="string">'F'</span>) &#123;</span><br><span class="line">                NumOfLoop++;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">                <span class="keyword">if</span> (vis[str1[<span class="number">0</span>] - <span class="number">96</span>]) &#123;</span><br><span class="line">                    NumOfLoop = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                	vis[str1[<span class="number">0</span>] - <span class="number">96</span>] = <span class="number">1</span>;</span><br><span class="line">                    var[NumOfLoop] = str1[<span class="number">0</span>] - <span class="number">96</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">                <span class="keyword">if</span> (str1[<span class="number">0</span>] != <span class="string">'n'</span> &amp;&amp; str2[<span class="number">0</span>] == <span class="string">'n'</span> &amp;&amp; Kill == <span class="number">0</span>) &#123;</span><br><span class="line">                    Onow++;</span><br><span class="line">                    AddO[NumOfLoop] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((str1.length() == str2.length() &amp;&amp; str1 &gt; str2) || (str1.length() &gt; str2.length()) || (str1[<span class="number">0</span>] == <span class="string">'n'</span> &amp;&amp; str2[<span class="number">0</span>] != <span class="string">'n'</span>)) &amp;&amp; Kill == <span class="number">0</span>) &#123;</span><br><span class="line">                    Kill = <span class="number">1</span>;</span><br><span class="line">                    WhereKill = NumOfLoop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                Omax = max(Omax, Onow);</span><br><span class="line">                vis[var[NumOfLoop]] = <span class="number">0</span>; </span><br><span class="line">                <span class="keyword">if</span> (AddO[NumOfLoop] == <span class="number">1</span>) &#123;</span><br><span class="line">                    Onow--;</span><br><span class="line">                    AddO[NumOfLoop] = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                NumOfLoop--; </span><br><span class="line">                <span class="keyword">if</span> (WhereKill &gt; <span class="number">0</span> &amp;&amp; NumOfLoop &lt; WhereKill) &#123;</span><br><span class="line">                    Kill = <span class="number">0</span>; WhereKill = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(NumOfLoop == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ERR\n"</span>);</span><br><span class="line">                cal = <span class="number">-1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"ERR\n"</span>); </span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop == <span class="number">0</span> &amp;&amp; Omax == O) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop == <span class="number">0</span> &amp;&amp; Omax != O) <span class="built_in">printf</span>(<span class="string">"No\n"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 34ms 756kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D1T3-逛公园"><a href="#D1T3-逛公园" class="headerlink" title="$D1T3$ 逛公园"></a>$D1T3$ <a href="https://www.luogu.org/problemnew/show/P3953" target="_blank" rel="noopener">逛公园</a></h2><p>本题思路来自<a href="https://www.luogu.org/blog/Annie-007/ti-xie-p3953-guang-gong-yuan" target="_blank" rel="noopener">安妮007的题解</a></p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ol>
<li>先SPFA求最短路</li>
<li>再反向SPFA排除无法到达的边</li>
<li>再记忆化搜索走冤枉路的最优方案</li>
</ol>
<p>详细见<a href="https://www.luogu.org/blog/Annie-007/ti-xie-p3953-guang-gong-yuan" target="_blank" rel="noopener">安妮007的题解</a></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Node(<span class="keyword">int</span> x, <span class="keyword">int</span> y): x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, p, T;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; v[maxn], s[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn], ans[maxn][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][<span class="number">60</span>], alive[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q, f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//a当前点,b允许走的冤枉路长度</span></span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[a][b] == <span class="number">1</span>) &#123;  <span class="comment">//又回来了</span></span><br><span class="line">        <span class="keyword">return</span> -inf;              <span class="comment">//无穷多种(-inf用于判断)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ans[a][b] != <span class="number">-1</span>) &#123; <span class="comment">//算过了</span></span><br><span class="line">        <span class="keyword">return</span> ans[a][b];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vis[a][b] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == n) &#123; <span class="comment">//到目的地</span></span><br><span class="line">            key++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[a].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = v[a][i].x, y = v[a][i].y; <span class="comment">//g本条边终点,y权值</span></span><br><span class="line">            <span class="keyword">int</span> u = d[g] - d[a];</span><br><span class="line">            <span class="keyword">if</span> (alive[g] == <span class="number">0</span>) &#123; <span class="comment">//不能到终点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> w = dfs(g, b - (y - u));</span><br><span class="line">            <span class="keyword">if</span> (w == -inf) &#123;</span><br><span class="line">                <span class="keyword">return</span> -inf;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                key = (key + w) % p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[a][b] = key % p;</span><br><span class="line">        vis[a][b] = <span class="literal">false</span>; <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe</span><span class="params">()</span> </span>&#123; <span class="comment">//排除无法到终点的点(反向SPFA)</span></span><br><span class="line">    f.push(n);</span><br><span class="line">    alive[n] = <span class="number">1</span>;  <span class="comment">//点n自身可以到达</span></span><br><span class="line">    <span class="keyword">while</span> (!f.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = f.front(); f.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[h].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = s[h][i].x;</span><br><span class="line">            <span class="keyword">if</span> (alive[g] == <span class="number">0</span>) &#123;</span><br><span class="line">                alive[g] = <span class="number">1</span>;</span><br><span class="line">                f.push(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123; <span class="comment">//SPFA求最短路</span></span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[h].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = v[h][i].x, y = v[h][i].y;</span><br><span class="line">            <span class="keyword">if</span> (d[h] + y &lt; d[g]) &#123;</span><br><span class="line">                d[g] = d[h] + y;</span><br><span class="line">                q.push(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;k, &amp;p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            v[i].clear();</span><br><span class="line">            s[i].clear();</span><br><span class="line">            alive[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                ans[i][j] = <span class="number">-1</span>;</span><br><span class="line">                vis[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            v[a].push_back(Node(b, c));     <span class="comment">//正向边</span></span><br><span class="line">            s[b].push_back(Node(a, c));     <span class="comment">//反向边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            d[i] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">        spfa();  <span class="comment">//SPFA求最短路</span></span><br><span class="line">        safe();</span><br><span class="line">        <span class="keyword">int</span> z = dfs(<span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">if</span> (z == -inf) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 6488ms 44632kB with O2 */</span></span><br></pre></td></tr></table></figure>
<h2 id="D2T1-奶酪"><a href="#D2T1-奶酪" class="headerlink" title="$D2T1$ 奶酪"></a>$D2T1$ <a href="https://www.luogu.org/problemnew/show/P3958" target="_blank" rel="noopener">奶酪</a></h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>没什么好说的,直接<strong><em>搜索</em></strong><br>存好每个点,排序,从下向上搜</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> fini = <span class="literal">false</span>, vis[maxn];</span><br><span class="line"><span class="keyword">int</span> T, n, h, r;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, z;</span><br><span class="line">&#125; node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &gt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>) + <span class="built_in">pow</span>(a.z - b.z, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node now, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now.z + r &gt;= h) &#123;</span><br><span class="line">        fini = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[num] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fini) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vis[i] &amp;&amp; dist(node[i], now) &lt;= r * <span class="number">2</span>) &#123;</span><br><span class="line">            dfs(node[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        fini = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(node));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;h, &amp;r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf %lf %lf"</span>, &amp;node[i].x, &amp;node[i].y, &amp;node[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(node + <span class="number">1</span>, node + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node[i].z - r &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(node[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(fini ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 157ms 832kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D2T2-宝藏"><a href="#D2T2-宝藏" class="headerlink" title="$D2T2$ 宝藏"></a>$D2T2$ <a href="https://www.luogu.org/problemnew/show/P3959" target="_blank" rel="noopener">宝藏</a></h2><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>状压?? 模拟退火?? <del>不存在的</del> 蒟蒻不会<br><strong><em>搜索+剪枝</em></strong>能很快AC掉这道紫题<br>不解释了</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">20</span>], dis[<span class="number">20</span>], num[<span class="number">20</span>]; <span class="comment">//已访问的点,距1的距离,可以到达的点数</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">20</span>][<span class="number">20</span>], G[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">//费用,图</span></span><br><span class="line"><span class="keyword">int</span> ans = inf, tmp, tot, cnt, n, m, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[p][a] &lt; c[p][b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot + tmp * dis[vis[i]] &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = node; j &lt;= num[vis[i]]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dis[G[vis[i]][j]]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[cnt] = G[vis[i]][j];</span><br><span class="line">                tmp -= c[vis[cnt]][G[vis[cnt]][<span class="number">1</span>]];</span><br><span class="line">                tot += c[vis[i]][vis[cnt]] * dis[vis[i]];</span><br><span class="line">                dis[vis[cnt]] = dis[vis[i]] + <span class="number">1</span>;</span><br><span class="line">                dfs(i, j + <span class="number">1</span>);</span><br><span class="line">                tot -= c[vis[i]][vis[cnt]] * dis[vis[i]];</span><br><span class="line">                dis[vis[cnt]] = <span class="number">0</span>;</span><br><span class="line">                tmp += c[vis[cnt]][G[vis[cnt]][<span class="number">1</span>]];</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot &lt; ans) ans = tot;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            c[i][j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="keyword">if</span>(c[u][v] &lt; w) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[u][v] == inf) &#123;</span><br><span class="line">            G[u][++num[u]] = v;</span><br><span class="line">            G[v][++num[v]] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        c[u][v] = c[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = i;</span><br><span class="line">        sort(G[i] + <span class="number">1</span>, G[i] + <span class="number">1</span> + num[i], cmp);</span><br><span class="line">        tmp += c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        tot = <span class="number">0</span>; cnt = <span class="number">1</span>;</span><br><span class="line">        vis[<span class="number">1</span>] = i;</span><br><span class="line">        tmp -= c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">        dis[i] = <span class="number">1</span>; </span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        dis[i] = <span class="number">0</span>;</span><br><span class="line">        tmp += c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 65ms 808kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D2T3-列队"><a href="#D2T3-列队" class="headerlink" title="$D2T3$ 列队"></a>$D2T3$ <a href="https://www.luogu.org/problemnew/show/P3960" target="_blank" rel="noopener">列队</a></h2><p>平衡树?? $Splay$?? $FHQ\_Treap$?? <del>不会</del><br>模拟拿下$50$分,以后再说,<del>逃</del></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, q, tot;</span><br><span class="line">LL last[maxn], h[maxn], pos[<span class="number">510</span>][<span class="number">50010</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read(); q = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        a[i].x = read();</span><br><span class="line">        a[i].y = read();</span><br><span class="line">        h[i] = a[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        last[i] = last[i - <span class="number">1</span>] + m;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h + <span class="number">1</span>, h + q + <span class="number">1</span>);                 <span class="comment">//排序</span></span><br><span class="line">    tot = unique(h + <span class="number">1</span>, h + q + <span class="number">1</span>) - h - <span class="number">1</span>; <span class="comment">//去重</span></span><br><span class="line">    LL t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123; <span class="comment">//编号</span></span><br><span class="line">        t = (LL)(h[i] - <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            pos[i][j] = ++t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> where; <span class="comment">//a[i].x在h数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123; <span class="comment">//模拟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[j] == a[i].x) &#123;</span><br><span class="line">                where = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i].y == m) &#123; <span class="comment">//在最后一列</span></span><br><span class="line">            ans = last[h[where]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = pos[where][a[i].y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">        <span class="keyword">if</span> (a[i].y != m) &#123; <span class="comment">//向左看齐</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i].y; j &lt; m - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                pos[where][j] = pos[where][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            pos[where][m - <span class="number">1</span>] = last[h[where]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h[where]; j &lt; n; ++j) &#123; <span class="comment">//向前看齐</span></span><br><span class="line">            last[j] = last[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        last[n] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 50Points 13662ms 67344kB */</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2018」题解</title>
    <url>/p/34a76f7d.html</url>
    <content><![CDATA[<pre><code>emmm，今天开始从2018向前做NOIp的真题，并写一些题解，太蒻了Orz
</code></pre><a id="more"></a>
<h2 id="D1T1-铺设道路"><a href="#D1T1-铺设道路" class="headerlink" title="$D1T1$ 铺设道路"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P5019" target="_blank" rel="noopener">铺设道路</a></h2><p>嗯～13年原题，<strong><em>贪心AC</em></strong></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对区间进行“填坑”<br>贪心策略：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (d[i] &gt; d[i - <span class="number">1</span>]) ans += d[i] - d[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>$proof:$<br>    假设现在有一个坑，旁边还有一个坑。<br>    那肯定会同时填上两个坑，所以<strong>小的坑会被大的坑带着填上</strong>，及<strong><em>小坑免费，大坑减少<code>a[i] - a[i - 1]</code></em></strong><br>$Q.E.D$<br>结果还要加上<code>a[1]</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] &gt; d[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            ans += d[i] - d[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans + d[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 41ms 1220kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D1T2-货币系统"><a href="#D1T2-货币系统" class="headerlink" title="$D1T2$ 货币系统"></a>$D1T2$ <a href="https://www.luogu.org/problemnew/show/P5020" target="_blank" rel="noopener">货币系统</a></h2><p>表面上是数论，其实就是个<strong><em>动态规划</em></strong></p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先设$A = (n, a) \ \ B = (m, b)$<br>可以证明$B \subseteq A$<br>$proof:$<br>    我们设$x\in A$且$x$不能被$A$集合内除它以外的元素组成。<br>    然后我们假设$x \notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。<br>    那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。<br>    综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内<br>$Q.E.D$</p>
<p>然后动态规划<br><code>dp[i]</code>表示$i$面值最多能被几张钱表示<br>则若其不能被表示<code>dp[i] = -inf</code><br>能表示且只有它自己则<code>dp[i] = 1</code><br>初始化<code>dp[] = -inf; dp[0] = 0</code><br>状态转移方程为<code>dp[j] = max(dp[j], dp[j - a[i]] + 1)</code></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, ans, a[<span class="number">1010</span>], dp[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        ans = <span class="number">0</span>; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= <span class="number">25010</span>; ++j) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - a[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[a[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 862ms 944kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D1T3-赛道修建"><a href="#D1T3-赛道修建" class="headerlink" title="$D1T3$ 赛道修建"></a>$D1T3$ <a href="https://www.luogu.org/problemnew/show/P5021" target="_blank" rel="noopener">赛道修建</a></h2><p>这题比较复杂，先得部分分</p>
<h3 id="I-m-1-时"><a href="#I-m-1-时" class="headerlink" title="$I.$ $m = 1$ 时"></a>$I.$ $m = 1$ 时</h3><p>最简单的情况<br>求一条最长链，即求树的直径（记录一下最大值和次大值，每次把最大值传到它的父亲）<br>可以通过第$1,4,5,6$个点，$20$分</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Meq1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            res2 = max(res2, dfs(to, now) + edges[i].val);</span><br><span class="line">            <span class="keyword">if</span> (res2 &gt; res1) swap(res1, res2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, res1 + res2);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="II-a-i-1-时"><a href="#II-a-i-1-时" class="headerlink" title="$II.$ $a_i = 1$ 时"></a>$II.$ $a_i = 1$ 时</h3><p>即一个菊花图<br>把所有边权记录下来，从大到小排序。设边权为$w$，答案即为$w_1+w_{2m-1},w_2+w_{2m-2},…,w_m+w_{m+1}$的最小值<br>可以通过$1,5,7,8$四个点，$20$分，加上$m = 1$的情况共$35$分</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Aeq1 &#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxn];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            arr[to - <span class="number">1</span>] = edges[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr + <span class="number">1</span>, arr + n, cmp);</span><br><span class="line">        ans = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            ans = min(ans, arr[i] + arr[<span class="number">2</span> * m - i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="III-b-i-a-i-1-时"><a href="#III-b-i-a-i-1-时" class="headerlink" title="$III.$ $b_i = a_i + 1$ 时"></a>$III.$ $b_i = a_i + 1$ 时</h3><p>为一条链<br>把所有边权记录下来，这种情况等价于将序列分割成$m$段，使$m$段区间和的最小值最大<br>那么二分$m$段区间和的最小值，然后贪心扫一遍<br>可以通过$2,9,10,11$四个点，$20$分，加上一共$55$分</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BeqApl1 &#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxn], ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            res2 = max(res2, Dfs(to, now) + edges[i].val);</span><br><span class="line">            <span class="keyword">if</span> (res2 &gt; res1) swap(res1, res2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, res1 + res2);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(to, now);</span><br><span class="line">            arr[now] = edges[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now + arr[i] &gt;= x) &#123;</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">                t++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                now += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        Dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = ans, mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (judge(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>最小值最大，显然是二分这个最小值$lim$<br>对于一个节点$u$，我们可以记录一个连接到$u$的赛道的长度$val_i$，那么可以分成两种情况进行讨论：<br>$$\begin{cases} val_i+dis \geq lim \text{直接给答案+1} \\ val_i+dis&lt; lim \text{利用优先队列维护}\end{cases}$$</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, num, s[maxn], mid;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w) : from(u), to(v), val(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[u].push_back(Edge(u, v, w));</span><br><span class="line">    G[v].push_back(Edge(v, u, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; lh;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; sh;</span><br><span class="line">    <span class="keyword">int</span> ln = <span class="number">0</span>, sn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[u][i].to != fa) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = G[u][i].val + dfs(G[u][i].to, u);</span><br><span class="line">            sh.push(d); lh.push(d);</span><br><span class="line">            ln++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ln &gt; <span class="number">0</span> &amp;&amp; lh.top() &gt;= mid) &#123;num++; lh.pop(); ln--;&#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ln &gt; sn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="number">1</span> &amp;&amp; lh.top() + sh.top() &gt;= mid) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ln &gt; sn &amp;&amp; lh.top() + sh.top() &gt;= mid) &#123;s[++cnt] = lh.top(); lh.pop(); ln--;&#125;</span><br><span class="line">            num++; sh.pop(); sn++;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>) &#123;lh.push(s[--cnt]); ln++;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == <span class="number">1</span> &amp;&amp; lh.top() + sh.top() &gt;= mid) &#123;</span><br><span class="line">            lh.pop(); sh.pop(); ln--; sn++; num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now = sh.top(); sh.pop(); sn++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= m) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ln &gt;= sn &amp;&amp; !lh.empty()) <span class="keyword">return</span> lh.top();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n); read(m); <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        read(u); read(v); read(w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        all += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = all / m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check()) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1050ms 11964kB with O2 */</span></span><br></pre></td></tr></table></figure>
<h2 id="D2T1-旅行"><a href="#D2T1-旅行" class="headerlink" title="$D2T1$ 旅行"></a>$D2T1$ <a href="https://www.luogu.org/problemnew/show/P5022" target="_blank" rel="noopener">旅行</a></h2><p>分两种情况讨论</p>
<h3 id="I-m-n-1"><a href="#I-m-n-1" class="headerlink" title="$I.$ $m = n - 1$"></a>$I.$ $m = n - 1$</h3><p>即无环，只要给一个点所能到达的点的编号进行一次从小到大的排序，在树上dfs一遍即可解决<br>样例1图示：<img src="/p/34a76f7d/P5022_1.png" alt></p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SolveOne &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        ans[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                dfs(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sort(G[i].begin(), G[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1050ms 11964kB with O2 */</span></span><br></pre></td></tr></table></figure>
<h3 id="II-m-n"><a href="#II-m-n" class="headerlink" title="$II.$ $m = n$"></a>$II.$ $m = n$</h3><p>存在一个环（基环树）<br>手算一下样例2可以发现，有且仅有一条边不会通过<br>逐个删边尝试即可，删边后和$m = n - 1$相同<br>样例2图示：<img src="/p/34a76f7d/P5022_2.png" alt></p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans[maxn], in[maxn][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SolveOne &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        ans[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                dfs(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sort(G[i].begin(), G[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SolveTwo &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, res[maxn], du, dv;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">notdel</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">//判断该边是否被删</span></span><br><span class="line">        <span class="keyword">if</span> ((u == du &amp;&amp; v == dv) || (u == dv &amp;&amp; v == du)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        res[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; notdel(u, v)) &#123;</span><br><span class="line">                dfs(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123; <span class="comment">//判断是否为更优情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i] != res[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans[i] &gt; res[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sort(G[i].begin(), G[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res));</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            du = in[i][<span class="number">0</span>]; <span class="comment">//删边</span></span><br><span class="line">            dv = in[i][<span class="number">1</span>];</span><br><span class="line">            dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (judge() &amp;&amp; cnt == n) &#123; <span class="comment">//如果更优则更改ans[]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(ans, res, <span class="keyword">sizeof</span>(res));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">        in[i][<span class="number">0</span>] = u;  <span class="comment">//存储输入信息</span></span><br><span class="line">        in[i][<span class="number">1</span>] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == n - <span class="number">1</span>) &#123;</span><br><span class="line">        SolveOne::solve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SolveTwo::solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2244ms 1276kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D2T2-填数游戏"><a href="#D2T2-填数游戏" class="headerlink" title="$D2T2$ 填数游戏"></a>$D2T2$ <a href="https://www.luogu.org/problemnew/show/P5023" target="_blank" rel="noopener">填数游戏</a></h2><p><del>暴力推柿子</del><br>首先明确一个概念:本文的对角线指的是从左下方到右上方的有向线段<br><img src="/p/34a76f7d/d2t2_1.png" alt="Lemma I."><br>$\mathcal{Lemma}\ I.$ 对角线上的数只会相同或递减<br>$proof:$<br>由上图两条黑线和题目描述即可证明<br>$Q.E.D$</p>
<p><img src="/p/34a76f7d/d2t2_2.png" alt="Lemma II."><br>$\mathcal{Lemma}\ II.$ 若$(x-1, y)$与$(x, y-1)$的数相同,则以$(x,y)$为左上角,整个图形右下角的子矩阵的每条对角线(蓝)上填的数字相同<br>$proof:$<br>由图上两条橙线及题目描述即可证明<br>$Q.E.D$</p>
<p>$\mathcal{Lemma}\ III.$ $Ans(n,m)=Ans(m,n)$</p>
<p>正式推式子(默认$n \leq m$)</p>
<h3 id="I-n-1-时"><a href="#I-n-1-时" class="headerlink" title="$I.$ $n = 1$ 时"></a>$I.$ $n = 1$ 时</h3><p><img src="/p/34a76f7d/d2t2_3.png" alt><br>每个格内都有2种填法,故$\Ans(1,m)=2^{m}$</p>
<h3 id="II-n-2-时"><a href="#II-n-2-时" class="headerlink" title="$II.$ $n = 2$ 时"></a>$II.$ $n = 2$ 时</h3><p><img src="/p/34a76f7d/d2t2_4.png" alt><br>两个角上各两种,剩余$m-1$条对角线每条有3种(11,10,00)<br>故$Ans(2,m)=2\times 2\times 3^{m-1}=4\times 3^{m-1}$</p>
<h3 id="III-n-geq-4-时-只考虑-n-m-时"><a href="#III-n-geq-4-时-只考虑-n-m-时" class="headerlink" title="$III. $ $n \geq 4$ 时 (只考虑$n = m$时)"></a>$III. $ $n \geq 4$ 时 (只考虑$n = m$时)</h3><h4 id="case-I-左上角两数相同"><a href="#case-I-左上角两数相同" class="headerlink" title="$case I.$ 左上角两数相同"></a>$case I.$ 左上角两数相同</h4><p><img src="/p/34a76f7d/d2t2_5.png" alt><br>图中数字表示每条对角线方案数<br>可以得出$Ans(caseI.)=2\times 2\times 4^{n-2}\times 2^{n-1}=8^{n-1}$</p>
<h4 id="case-II-第三条对角线数字相同"><a href="#case-II-第三条对角线数字相同" class="headerlink" title="$case II.$ 第三条对角线数字相同"></a>$case II.$ 第三条对角线数字相同</h4><p><img src="/p/34a76f7d/d2t2_6.png" alt><br>图中红色数字表示方案数<br>可以得出$Ans(caseII.)=2\times 2\times 5\times 4^{n-4}\times 2^{n-1}=5\times 2^{3n-7}$</p>
<h4 id="case-III-第三条对角线上数字不同"><a href="#case-III-第三条对角线上数字不同" class="headerlink" title="$case III.$ 第三条对角线上数字不同"></a>$case III.$ 第三条对角线上数字不同</h4><p><img src="/p/34a76f7d/d2t2_7.png" alt><br>可以发现左侧两行只能填01,所以可能会再次出现对角数字相同的情况</p>
<h5 id="第一个出现"><a href="#第一个出现" class="headerlink" title="第一个出现"></a>第一个出现</h5><p><img src="/p/34a76f7d/d2t2_8.png" alt="红色表示方案数"></p>
<h5 id="最后一个出现"><a href="#最后一个出现" class="headerlink" title="最后一个出现"></a>最后一个出现</h5><p><img src="/p/34a76f7d/d2t2_9.png" alt></p>
<h5 id="倒数第二个出现"><a href="#倒数第二个出现" class="headerlink" title="倒数第二个出现"></a>倒数第二个出现</h5><p><img src="/p/34a76f7d/d2t2_10.png" alt></p>
<h5 id="没有出现"><a href="#没有出现" class="headerlink" title="没有出现"></a>没有出现</h5><p><img src="/p/34a76f7d/d2t2_11.png" alt></p>
<p>注意第三条对角线可能有100,110两种情况<br>所以$Ans(case III.)=2\times (2\times 4\times 5\times 2^{n-1}\times \sum_{i=0}^{n-5}{4^i} + 2\times 4\times 3\times 2^{n-2} + 2\times 3\times 2^{n-2})$</p>
<p>$Ans(n, n)=Ans(case I.) + Ans(case II.) + Ans(case III.)$<br>$$Ans(n,n)=\frac{83\times 8^n + 5\times 2^{n+7}}{384}$$</p>
<h3 id="IV-n-3"><a href="#IV-n-3" class="headerlink" title="$IV.$ $n = 3$"></a>$IV.$ $n = 3$</h3><p>证明与前类似<br>$$Ans(3,m)=112\times 3^{m-3}$$</p>
<h3 id="V-n-neq-m-时"><a href="#V-n-neq-m-时" class="headerlink" title="$V.$ $n \neq m$ 时"></a>$V.$ $n \neq m$ 时</h3><p>与前类似<br>$$Ans(n,n+1)=\frac{83\times 8^n + 2^{n+8}}{128}$$<br>同时易证得$Ans(n,m+1)=3\times Ans(n,m)$</p>
<p>于是就解决了</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">poww</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> ( ; b; a = a * a % mod, b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, poww(<span class="number">2</span>, m));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">4</span> * poww(<span class="number">3</span>, m - <span class="number">1</span>) % mod);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">112</span> * poww(<span class="number">3</span>, m - <span class="number">3</span>) % mod);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ((<span class="number">83</span> * poww(<span class="number">8</span>, n) % mod + <span class="number">5</span> * poww(<span class="number">2</span>, n + <span class="number">7</span>) % mod) * <span class="number">190104168</span> % mod));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ((<span class="number">83</span> * poww(<span class="number">8</span>, n) % mod + poww(<span class="number">2</span>, n + <span class="number">8</span>)) * poww(<span class="number">3</span>, m - n - <span class="number">1</span>) % mod * <span class="number">570312504</span> % mod ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 55ms 1048kB */</span></span><br></pre></td></tr></table></figure>
<h2 id="D2T3-保卫王国"><a href="#D2T3-保卫王国" class="headerlink" title="$D2T3$ 保卫王国"></a>$D2T3$ <a href="https://www.luogu.org/problemnew/show/P5024" target="_blank" rel="noopener">保卫王国</a></h2><p>动态DP,树剖,<del>蒟蒻不会</del></p>
<p><del>逃</del></p>
<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」太空飞行计划问题-题解</title>
    <url>/p/f5a4cbbc.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2762" target="_blank" rel="noopener">「Luogu P2762」太空飞行计划问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$m$个实验，每个实验只可以进行一次，但会获得相应的奖金<br>有$n$个仪器，每个实验都需要一定的仪器，每个仪器可以运用于多个实验，但需要一定的价值</p>
<p>问奖金与代价的差的最大值是多少？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol>
<li>从源点向每个实验建 <strong>容量为实验奖金</strong> 的边</li>
<li>从每个仪器向汇点建 <strong>容量为仪器费用</strong> 的边</li>
<li>实验向对应仪器建 <strong>容量为$inf$</strong> 的边(保证不被割)</li>
</ol>
<p>然后求最小割即最大流,只会割断 <strong>源-&gt;实验</strong> 或者 <strong>仪器-&gt;汇</strong> 的点<br>最后一次bfs后,仍和源相连的实验/仪器为要进行的实验/需要的仪器</p>
<p>最大收益为所有支付的费用之和减最大流</p>
<p>样例的建边见下图:<br><img src="/p/f5a4cbbc/NF24P2762.png" alt></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> endr = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'\r'</span>) endr = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn], tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.push_back((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += DFS(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_ = read(), n_ = read();</span><br><span class="line">    n = m_ + n_ + <span class="number">2</span>; s = <span class="number">0</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = read(); tot += p;</span><br><span class="line">        add(s, i, p);</span><br><span class="line">        <span class="keyword">char</span> tools[<span class="number">10000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(tools, <span class="number">0</span>, <span class="keyword">sizeof</span>(tools));</span><br><span class="line">        <span class="built_in">cin</span>.getline(tools, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">int</span> ulen = <span class="number">0</span>, tool;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">sscanf</span>(tools + ulen, <span class="string">"%d"</span>, &amp;tool) == <span class="number">1</span>) &#123;</span><br><span class="line">            add(i, tool + m_, inf);</span><br><span class="line">            <span class="keyword">if</span> (tool == <span class="number">0</span>) </span><br><span class="line">                ulen++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (tool) &#123;</span><br><span class="line">                    tool /= <span class="number">10</span>;</span><br><span class="line">                    ulen++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ulen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = read();</span><br><span class="line">        add(i + m_, t, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = dinic(s, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i + m_]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tot - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」孤岛营救问题-题解</title>
    <url>/p/5c532c45.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4011" target="_blank" rel="noopener">「Luogu P4011」孤岛营救问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>起点为$(1,1)$,终点为$(n,m)$<br>有些格子上有若干个钥匙，两个格子之间可能有一堵墙或者一扇可以用对应钥匙打开的门<br>每次移动需要$1$个单位时间，其他动作不需要时间</p>
<p>求最少需要多少时间能从起点到达终点。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对拥有的钥匙状态进行压缩<br>从起点到终点跑bfs即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p, k;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn][maxn], key[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> keys, times;</span><br><span class="line">    Node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k, <span class="keyword">int</span> t): x(x), y(y), keys(k), times(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> skey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[<span class="number">1</span>][<span class="number">1</span>]; ++i) skey |= (<span class="number">1</span> &lt;&lt; (key[<span class="number">1</span>][<span class="number">1</span>][i] - <span class="number">1</span>));</span><br><span class="line">    q.push(Node(<span class="number">1</span>, <span class="number">1</span>, skey, <span class="number">0</span>)); vis[<span class="number">1</span>][<span class="number">1</span>][skey] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span> (u.x == n &amp;&amp; u.y == m) <span class="keyword">return</span> u.times;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> vx = u.x + go[k][<span class="number">0</span>], vy = u.y + go[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (vx &lt; <span class="number">1</span> || vx &gt; n || vy &lt; <span class="number">1</span> || vy &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> e = edge[u.x][u.y][vx][vy];</span><br><span class="line">            <span class="keyword">if</span> (e &lt; <span class="number">0</span> || (e &gt; <span class="number">0</span> &amp;&amp; !(<span class="number">1</span> &lt;&lt; (e - <span class="number">1</span>) &amp; u.keys))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> vkeys = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[vx][vy]; ++i) vkeys |= (<span class="number">1</span> &lt;&lt; (key[vx][vy][i] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> nxtkeys = u.keys | vkeys;</span><br><span class="line">            <span class="keyword">if</span> (vis[vx][vy][nxtkeys]) <span class="keyword">continue</span>;</span><br><span class="line">            q.push(Node(vx, vy, nxtkeys, u.times + <span class="number">1</span>));</span><br><span class="line">            vis[vx][vy][nxtkeys] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read(); p = read(); k = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = read(), y1 = read(), x2 = read(), y2 = read();</span><br><span class="line">        <span class="keyword">int</span> g = read();</span><br><span class="line">        edge[x1][y1][x2][y2] = ((g == <span class="number">0</span>) ? <span class="number">-1</span> : g);</span><br><span class="line">        edge[x2][y2][x1][y1] = edge[x1][y1][x2][y2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = read(), y1 = read(), q = read();</span><br><span class="line">        key[x1][y1][++cnt[x1][y1]] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = bfs();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>最短路</tag>
        <tag>bfs</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」家园/星际转移问题-题解</title>
    <url>/p/af442de1.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2754" target="_blank" rel="noopener">「Luogu P2754」家园/星际转移问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>1个地球,$n$个太空站,1个月球,$k$个人<br>$m$艘船,第$i$艘容纳$h_i$个人,停靠$r_i$站,分别为$S_{i,j}$,每次耗时1<br>初始人全在地球,结束人全在月球</p>
<p>求最短时间</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先根据输入的停靠位置,建立并查集,若地月不连通,则无解,输出$0$</p>
<p>再根据时间建边,时间每增加1,增加一层,求一次最大流,添加进答案<br>当答案大于$k$时,即可全部到达月球</p>
<p>样例的建图是这样:<br><img src="/p/af442de1/NF24P2754.png" alt></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], ans, cur[maxn];</span><br><span class="line"><span class="keyword">int</span> ufs[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ufs[x] == x) ? x : ufs[x] = find(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) ufs[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.push_back((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += DFS(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read(); <span class="keyword">int</span> k = read();</span><br><span class="line">    s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) ufs[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        S[<span class="number">0</span>][i] = read(); S[i][<span class="number">0</span>] = read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= S[i][<span class="number">0</span>]; ++j) &#123;</span><br><span class="line">            S[i][j] = read();</span><br><span class="line">            <span class="keyword">if</span> (S[i][j] == <span class="number">-1</span>) S[i][j] = n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">1</span>) unionn(S[i][j], S[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (find(s) != find(t)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">1</span>; ; ++time) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            add(i + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), i + time * (n + <span class="number">2</span>), inf);</span><br><span class="line">        &#125;</span><br><span class="line">        add(n + <span class="number">1</span> + time * (n + <span class="number">2</span>), n + <span class="number">1</span> + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), inf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (time - <span class="number">1</span>) % S[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            add(S[i][tmp] + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), S[i][time % S[i][<span class="number">0</span>] + <span class="number">1</span>] + time * (n + <span class="number">2</span>), S[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += dinic(s, t);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= k) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」总结及图示</title>
    <url>/p/dccbc6bb.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">问题编号</th>
<th style="text-align:left">问题名称</th>
<th style="text-align:left">问题模型</th>
<th style="text-align:left">转化模型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2756" target="_blank" rel="noopener">飞行员配对方案问题</a></td>
<td style="text-align:left">二分图最大匹配</td>
<td style="text-align:left">网络最大流</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2762" target="_blank" rel="noopener">太空飞行计划问题</a></td>
<td style="text-align:left">最大权闭合图</td>
<td style="text-align:left">网络最小割</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2764" target="_blank" rel="noopener">最小路径覆盖问题</a></td>
<td style="text-align:left">有向无环图最小路径覆盖</td>
<td style="text-align:left">网络最大流</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2765" target="_blank" rel="noopener">魔术球问题</a></td>
<td style="text-align:left">有向无环图最小路径覆盖</td>
<td style="text-align:left">网络最大流</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P3254" target="_blank" rel="noopener">圆桌问题</a></td>
<td style="text-align:left">二分图多重匹配</td>
<td style="text-align:left">网络最大流</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2766" target="_blank" rel="noopener">最长不下降子序列问题</a></td>
<td style="text-align:left">最多不相交路径</td>
<td style="text-align:left">网络最大流</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2763" target="_blank" rel="noopener">试题库问题</a></td>
<td style="text-align:left">二分图多重匹配</td>
<td style="text-align:left">网络最大流</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2775" target="_blank" rel="noopener">机器人路径规划问题</a></td>
<td style="text-align:left">$IDA*$</td>
<td style="text-align:left">$IDA*$</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2774" target="_blank" rel="noopener">方格取数问题</a></td>
<td style="text-align:left">二分图点权最大独立集</td>
<td style="text-align:left">网络最小割</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P1251" target="_blank" rel="noopener">餐巾计划问题</a></td>
<td style="text-align:left">线性规划网络优化</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2770" target="_blank" rel="noopener">航空路线问题</a></td>
<td style="text-align:left">最长不相交路径</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2761" target="_blank" rel="noopener">软件补丁问题</a></td>
<td style="text-align:left">最小转移代价</td>
<td style="text-align:left">最短路径</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P2754" target="_blank" rel="noopener">星际转移问题</a></td>
<td style="text-align:left">网络判定</td>
<td style="text-align:left">网络最大流</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P4011" target="_blank" rel="noopener">孤岛营救问题</a></td>
<td style="text-align:left">分层图最短路径</td>
<td style="text-align:left">最短路径</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P4009" target="_blank" rel="noopener">汽车加油行驶问题</a></td>
<td style="text-align:left">分层图最短路径</td>
<td style="text-align:left">最短路径</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P4013" target="_blank" rel="noopener">数字梯形问题</a></td>
<td style="text-align:left">最大权不相交路径</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P4015" target="_blank" rel="noopener">运输问题</a></td>
<td style="text-align:left">网络费用流量</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P4014" target="_blank" rel="noopener">分配问题</a></td>
<td style="text-align:left">二分图最佳匹配</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P4016" target="_blank" rel="noopener">负载平衡问题</a></td>
<td style="text-align:left">最小代价供求</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P4012" target="_blank" rel="noopener">深海机器人问题</a></td>
<td style="text-align:left">线性规划网络优化</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P3358" target="_blank" rel="noopener">最长k可重区间集问题</a></td>
<td style="text-align:left">最大权不相交路径</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P3357" target="_blank" rel="noopener">最长k可重线段集问题</a></td>
<td style="text-align:left">最大权不相交路径</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P3356" target="_blank" rel="noopener">火星探险问题</a></td>
<td style="text-align:left">线性规划网络优化</td>
<td style="text-align:left">最小费用最大流</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:left"><a href="https://www.luogu.com.cn/problem/P3355" target="_blank" rel="noopener">骑士共存问题</a></td>
<td style="text-align:left">二分图最大独立集</td>
<td style="text-align:left">网络最小割</td>
</tr>
</tbody>
</table>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><ul>
<li><strong>最大匹配</strong>: 匈牙利/最大流</li>
<li><strong>带权匹配</strong>: KM/费用流</li>
<li><strong>最小点覆盖</strong>: =最大匹配</li>
<li><strong>最小边覆盖</strong>: =总结点数-最大匹配</li>
<li><strong>最大独立集</strong>: =总结点数-最大匹配</li>
</ul>
<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul>
<li>建立超级源点,超级汇点</li>
<li>点存在限制,拆成出入点,将出入点之间的边看做点,限制流量</li>
<li>建图考虑左右二部</li>
<li>超级源点向源点的边可以限制总流量</li>
<li>无源汇有容量下界:<code>s-下界-&gt;v  u-下界-&gt;t  u-上界减下界-&gt;v</code>,当满流时存在可行流</li>
<li>最小割中赋流量为inf则一定不会割去</li>
<li>一些求最大问题,可以用sum-最小割</li>
<li>最大权闭合图: 建图,最小割,仍和s相连的为最大权闭合图,权值和为sum-最小割</li>
</ul>
<h3 id="24题"><a href="#24题" class="headerlink" title="24题"></a>24题</h3><ol>
<li>直接建二分图,最大流求最大匹配</li>
<li>最大权闭合图,建边,实验和仪器之间保证不切割容量为inf,跑最小割,找与s相连的实验和仪器</li>
<li>最大独立集,总结点数-最大流</li>
<li>贪心</li>
<li>二分图多重匹配,s-&gt;左点集和右点集-&gt;t之间的边容量不为1(即可以选多次)</li>
<li>动态规划+按照动态规划的dp数组的意义建边求最大流</li>
<li>二分图多重匹配,类型-题目数-&gt;汇点,保证可选多个,存在满流则存在答案沿满流输出</li>
<li>$IDA*$爆搜,但洛谷数据应该有问题</li>
<li>抽象出两个点集,求最大独立集</li>
<li>按照题目说明建图,跑费用流</li>
<li>按照题目说明建图,跑费用流</li>
<li>将错误状态进行压缩,然后跑最短路</li>
<li>根据时间逐层建图,直到跑出可行流</li>
<li>将拥有钥匙进行压缩,跑最短路</li>
<li>建出分层图,跑最短路或者费用流</li>
<li>对三个规则分别建图,跑费用流</li>
<li>纯费用流</li>
<li>二分图最佳匹配,使用费用流</li>
<li>费用流,注意环形</li>
<li>按照题目要求建图,跑费用流</li>
<li>离散化,将区间转化为边,费用流</li>
<li>转化问题,变成21题,注意端点处理和垂直于x轴的线段</li>
<li>按照题目要求建图,跑费用流,方案dfs</li>
<li>将图上所有格点转化为两个点集,建二分图,求最大独立集</li>
</ol>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><strong><del>更新中</del></strong><br><img src="/p/f5a4cbbc/NF24P2762.png" alt="2"><br><img src="/p/af442de1/NF24P2754.png" alt="13"><br><img src="/p/949e7ebf/NF24P3358.png" alt="21"><br><img src="/p/f48af49a/NF24P3357.png" alt="22"></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」数字梯形问题-题解</title>
    <url>/p/86b4c1f9.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4013" target="_blank" rel="noopener">「Luogu P4013」数字梯形问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>梯形的第一行有$m$个数字<br>从梯形的顶部的$m$个数字开始,在每个数字处可以沿左下或右下方向移动,形成一条从梯形的顶至底的路径。</p>
<p>有三种规则:</p>
<ol>
<li>从梯形的顶至底的$m$条路径互不相交</li>
<li>从梯形的顶至底的$m$条路径仅在数字结点处相交</li>
<li>从梯形的顶至底的$m$条路径允许在数字结点相交或边相交</li>
</ol>
<p>求每种规则下经过数字的最大总和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很明显是 <strong>最大费用最大流</strong></p>
<h4 id="规则1"><a href="#规则1" class="headerlink" title="规则1."></a>规则1.</h4><p>路径不相交,即没有公共点,也就是每个点只能经过一次<br>将每个点拆成入点和出点,就可以通过控制出入点之间的容量控制经过次数</p>
<ol>
<li>从 源点 向 第一行的$m$个点的入点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 最后一行每个点的出点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 每个点的入点 向 每个点的出点 接一条 <strong>容量为$1$,费用为该点数字</strong> 的边(对答案贡献为该点数字)</li>
<li>从 每个点的出点 向 左下右下两个点的入点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
</ol>
<h4 id="规则2"><a href="#规则2" class="headerlink" title="规则2."></a>规则2.</h4><p>每条路径仅在数字节点相交,也就是不能有重边<br>无需拆点控制每个点经过的次数,只需给每条向左下右下的边的容量设为$1$,即只能经过一次</p>
<ol>
<li>从 源点 向 第一行的$m$个点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 最后一行每个点 接一条 <strong>容量为$inf$,费用为该点数字</strong> 的边(每个点可以使用多次)</li>
<li>从 每个点的 向 左下右下两个点 接一条 <strong>容量为$1$,费用为该点数字</strong> 的边</li>
</ol>
<h4 id="规则3"><a href="#规则3" class="headerlink" title="规则3."></a>规则3.</h4><p>边也可以重合,也就相当于没有规则,可以随意向左下右下走<br>只需将规则2.中建边3.的容量改成$inf$即可</p>
<p>对于每种情况,求出最大费用最大流,最大费用即为答案<br>注意求解规则2.3.之前要清空建的图</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大费用最大流模板部分省去了</span></span><br><span class="line"><span class="keyword">int</span> in[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="keyword">int</span> point[<span class="number">45</span>][<span class="number">45</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = read(); n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            in[i][j] = read();</span><br><span class="line">            point[i][j] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 1</span></span><br><span class="line">    s = <span class="number">0</span>; t = cnt * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) add(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) add(point[n][i] + cnt, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            add(point[i][j] + cnt, point[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            add(point[i][j] + cnt, point[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) </span><br><span class="line">            add(point[i][j], point[i][j] + cnt, <span class="number">1</span>, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 2</span></span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].clear();</span><br><span class="line">    s = <span class="number">0</span>; t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) add(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) add(point[n][i], t, inf, in[n][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        add(point[i][j], point[i + <span class="number">1</span>][j], <span class="number">1</span>, in[i][j]);</span><br><span class="line">        add(point[i][j], point[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 3</span></span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].clear();</span><br><span class="line">    s = <span class="number">0</span>; t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) add(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) add(point[n][i], t, inf, in[n][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        add(point[i][j], point[i + <span class="number">1</span>][j], inf, in[i][j]);</span><br><span class="line">        add(point[i][j], point[i + <span class="number">1</span>][j + <span class="number">1</span>], inf, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」方格取数问题-题解</title>
    <url>/p/40e04941.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2774" target="_blank" rel="noopener">「Luogu P2774」方格取数问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$m$行$n$列的方格图,每个方格中有一个正整数<br>从方格中取数,任意两个数所在方格没有公共边<br>求取出的数的最大总和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先选择所有方格,然后考虑删去一些方格<br>相邻$-&gt;$奇偶性不同,构成一个二分图,含有两个点集</p>
<ol>
<li>从 源点 向 点集$A$ 接一条 <strong>容量为点权</strong> 的边</li>
<li>从 点集$B$ 向 汇点 接一条 <strong>容量为点权</strong> 的边</li>
<li>从 点集$A$中每个点 向 与其相邻的在点集$B$中的点 接一条 <strong>容量为$inf$</strong> 的边(保证不被割)</li>
</ol>
<p>求出最小割即最大流即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.push_back((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += DFS(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = read(); n = read();</span><br><span class="line">    s = <span class="number">0</span>; t = n * m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = read(); tot += a;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                add(s, point(i, j), a);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = i + go[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = j + go[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;= nx &amp;&amp; nx &lt;= m &amp;&amp; <span class="number">1</span> &lt;= ny &amp;&amp; ny &lt;= n) &#123;</span><br><span class="line">                        add(point(i, j), point(nx, ny), inf);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(point(i, j), t, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = dinic(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tot - maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最小路径覆盖问题-题解</title>
    <url>/p/7973b062.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2764" target="_blank" rel="noopener">「Luogu P2764」最小路径覆盖问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>题目描述给的很直白,输入点数边数和有向边,输出最少路径数和路径</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>正常建图<br>如果一条路径的终点和另一条路径的起点有连边，那么这两条路径是可以合并的。<br>但是一个终点或起点只能使用一次。比如三条路径$1 \rightarrow 3, 2 \rightarrow 3, 3 \rightarrow 4$，你只能合并两条。<br>那么这道题就转化为了：最大化一个边集，使得边集中每个起点和终点都只使用过一次。即<strong>最大独立边集</strong>。<br>把每个点拆成入点$x$和出点$x’$,从源点到$x’$连一条容量为$1$的边，从$x$到汇点连一条容量为$1$的边。边权用来限制每个起点或终点的使用次数。<br>对于每条边$x \rightarrow y$，连接$x’ \rightarrow y$<br>答案是$n-最大流$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn], vst[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn], to[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : from(u), to(v), cap(c), flow(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="literal">true</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            to[x] = e.to;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += dfs(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    s = <span class="number">0</span>; t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v + n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(s, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(i + n, t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = maxflow(s, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vst[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i; vst[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">            <span class="keyword">while</span> (to[x] &amp;&amp; to[x] != t) &#123;</span><br><span class="line">                x = to[x] - n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">                vst[x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长k可重区间集问题-题解</title>
    <url>/p/949e7ebf.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3358" target="_blank" rel="noopener">「Luogu P3358」最长k可重区间集问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个开区间的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开区间,组成集合$\mathbf{S}$<br>使对于任何一个$x$,满足$\mathbf{S}$中包含$x$的区间数不超过$k$,且$\mathbf{S}$中开区间总长度最大</p>
<p>求最大的长度</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果两个区间没有重叠的话,则可以同时选择,在图上表现为串联<br>如果两个区间有重叠的话,则不能同时选择,在图上表现为并联(服从总流量的约束)<br>先对所有节点进行离散化,注意离散化前统计出区间的长</p>
<ol>
<li>从 源点 向 节点1 接一条 <strong>容量为$k$,费用为$0$</strong> 的边(最大容量为k,对答案无贡献)</li>
<li>从 每个节点$i$ 向 节点$i+1$ 接一条 <strong>容量为$inf$,费用为$0$</strong> 的边(可以随意通过,对答案无贡献)</li>
<li>从 最后一个节点 向 汇点 接一条 <strong>容量为$inf$,费用为$0$</strong> 的边(总流量有1.控制,对答案无贡献)(可以包含在2.里)</li>
<li>从 每个区间的左端点 向 其右端点 接一条 <strong>容量为$1$,费用为区间长</strong> 的边(只可用一次,对答案贡献为区间长度)</li>
</ol>
<p>求出最大费用最大流,最大费用即为最终的结果<br>样例的图如下:<br><img src="/p/949e7ebf/NF24P3358.png" alt></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.size();</span><br><span class="line">	G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.push(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;inter[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1020</span>], old[<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_ = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = read(); inter[i].r = read();</span><br><span class="line">        inter[i].len = inter[i].r - inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span> - <span class="number">1</span>] = inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span>] = inter[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) old[i] = nums[i];</span><br><span class="line">    sort(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = unique(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) nums[i] = lower_bound(old + <span class="number">1</span>, old + <span class="number">1</span> + len, nums[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = nums[i * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        inter[i].r = nums[i * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; n = len + <span class="number">2</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    add(s, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        add(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        add(inter[i].l, inter[i].r, <span class="number">1</span>, inter[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长k可重线段集问题-题解</title>
    <url>/p/f48af49a.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3357" target="_blank" rel="noopener">「Luogu P3357」最长k可重线段集问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个开线段的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开线段,组成集合$\mathbf{S}$<br>使对于任何一条直线$x=p$,满足$\mathbf{S}$中与$x=p$相交的线段数不超过$k$,且$\mathbf{S}$中开线段总长度最大</p>
<p>求最大的长度</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>和<a href="https://www.luogu.com.cn/problem/P3358" target="_blank" rel="noopener">「Luogu P3358」最长k可重区间集问题</a>类似<br>仅修改一下区间的输入部分即可</p>
<p>将每条线段映射到x轴上,发现可能不对,因为可能会存在垂直于x轴的线段,像P3358一样建图会省略掉这条线段</p>
<p>所以要将每个点扩大一倍,将左右端点x坐标相同的区间$(x, x)$更改为$(2x, 2x+1)$,使得不存在与x轴垂直的线段<br>如果左右端点x坐标不相同,则将$(x_1, x_2)$更改为$(2x_1+1, 2x_2)$</p>
<p>大概就是这么个道理:<br><img src="/p/f48af49a/NF24P3357.png" alt></p>
<p>剩下的做法和<a href="https://www.luogu.com.cn/problem/P3358" target="_blank" rel="noopener">P3358</a>一样,<a href="https://tony031218.github.io/2020/04/21/%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E6%9C%80%E9%95%BFk%E5%8F%AF%E9%87%8D%E5%8C%BA%E9%97%B4%E9%9B%86%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/">P3358题解</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.size();</span><br><span class="line">	G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.push(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;inter[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1020</span>], old[<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">long</span> <span class="keyword">long</span>)(a - c) * (a - c) + (<span class="keyword">long</span> <span class="keyword">long</span>)(b - d) * (b - d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_ = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = read(), b = read(), c = read(), d = read();</span><br><span class="line">        inter[i].len = length(a, b, c, d);</span><br><span class="line">        inter[i].l = a * <span class="number">2</span>;</span><br><span class="line">        inter[i].r = c * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == c) inter[i].r += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> inter[i].l += <span class="number">1</span>;</span><br><span class="line">        nums[i * <span class="number">2</span> - <span class="number">1</span>] = inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span>] = inter[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) old[i] = nums[i];</span><br><span class="line">    sort(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = unique(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) nums[i] = lower_bound(old + <span class="number">1</span>, old + <span class="number">1</span> + len, nums[i]) - old;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = nums[i * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        inter[i].r = nums[i * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; n = len + <span class="number">2</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    add(s, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        add(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        add(inter[i].l, inter[i].r, <span class="number">1</span>, inter[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长不下降子序列问题-题解</title>
    <url>/p/a66cf8af.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2766" target="_blank" rel="noopener">「Luogu P2766」最长不下降子序列问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定正整数序列$x_1, x_2, …, x_n$ </p>
<ol>
<li>计算其 <strong>最长不下降子序列</strong> 的长度$S$</li>
<li>如果每个元素只允许使用一次,计算从给定的序列中最多可取出多少个长度为$S$的不下降子序列</li>
<li>如果允许在取出的序列中多次使用$x_1$和$x_n$,其他元素仍然只允许使用一次,则从给定序列中最多可取出多少个 <strong>不同</strong> 的长度为$S$的不下降子序列</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h4><p>动态规划<br><strong>状态转移方程</strong>:$\mathtt{f[i]=max_{1≤j&lt;i\&amp;\&amp;x_j≤x_i}\{f[j]+1\}}$<br><strong>初值</strong>: $\mathtt{f[0]=0}$<br><strong>结果</strong>: $\mathtt{max_{1\leq i\leq n}f[i]}$</p>
<h4 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h4><p>将每个点(索引)拆成两个点<br>应用了分层图的思想, 把图每个顶点$\mathtt{i}$按照$\mathtt{f[i]}$的不同分为了若干层<br>这样图中从$s$出发到$t$的任何一条路径都是一个满足条件的最长上升子序列<br>由于序列中每个点要不可重复地取出,需要把每个点拆分成两个点<br>单位网络的最大流就是增广路的条数,所以最大流量就是第二问结果。</p>
<ol>
<li>从 源点 向 每个$\mathtt{f[i]==1}$的点i的左点 建一条 <strong>容量为1</strong> 的边</li>
<li>从 每个点的左点 向 其右点 建一条 <strong>容量为1</strong> 的边</li>
<li>从 $\mathtt{f[i]==S}$的点i的右点 向 汇点 建一条 <strong>容量为1</strong> 的边</li>
<li>对于$j&lt;i$,若$\mathtt{x_j\leq x_i \&amp;\&amp; f[i] == f[j] + 1}$,则从 点j的右点 向 点i的左点 建一条 <strong>容量为1</strong> 的边</li>
</ol>
<h4 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h4><p>要求$x_1$和$x_n$可以重复使用,只需取消这两个点相关边的流量限制,求网络最大流即可</p>
<ol>
<li>从 源点 向 点1的左点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>从 点1的左点 向 点1的右点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>若$\mathtt{f[n]==S}$则从 点n的左点 向 点n的右点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>若$\mathtt{f[n]==S}$则从 点n的右点 向 汇点 建一条 <strong>容量为$inf$</strong> 的边</li>
</ol>
<p>注意判断当$n==1$时的情况(第三问答案会出现$inf$)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.push_back((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += DFS(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">510</span>], dp[<span class="number">510</span>], ans1, ans2, ans3; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        num[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt;= num[i] &amp;&amp; dp[j] &gt; dp[i]) dp[i] = dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]++;</span><br><span class="line">        ans1 = max(ans1, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 2</span></span><br><span class="line">    s = <span class="number">0</span>, t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dp[i] == <span class="number">1</span>) add(s, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(i, i + n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dp[i] == ans1) add (i + n, t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) </span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt;= num[i] &amp;&amp; dp[i] == dp[j] + <span class="number">1</span>)</span><br><span class="line">                add(j + n, i, <span class="number">1</span>);</span><br><span class="line">    ans2 = dinic(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    add(s, <span class="number">1</span>, inf); add(<span class="number">1</span>, <span class="number">1</span> + n, inf);</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == ans1) &#123;</span><br><span class="line">        add(n, n + n, inf);</span><br><span class="line">        add(n + n, t, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    ans3 = ans2 + dinic(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」汽车加油行驶问题-题解</title>
    <url>/p/fab3e888.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4009" target="_blank" rel="noopener">「Luogu P4009」汽车加油行驶问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个$N\times N$的网格,表示有加油站的位置<br>汽车要从$(1, 1)$走到$(N, N)$,装满油可以行驶$K$条边,且只能沿边行驶<br>服从以下规则</p>
<ol>
<li>可以无费用向右或向下走,但耗1点油</li>
<li>向左走或者向上走时需要付费用$B$,并耗1点油</li>
<li>在加油站处,若油没满,则必须付费用$A$,加满油</li>
<li>可在没有加油站的位置开设加油站,费用$C$,并加满油,付费$A$</li>
<li>在起点处,油量为$K$</li>
</ol>
<p>求出最小费用</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>明显是最小费用最大流(其实分层图最短路也可以解决,因为每条边的容量都为1)<br>分层建图,每层表示油量,第$0$层表示满油($K$),第$1$层表示油量为$K-1$,第$2$层表示油量为$K-2$,$…$</p>
<ol>
<li>对于每层每个节点,如果不是加油站,则从 该点 向 下一层的右边和下边的节点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边(规则1.)</li>
<li>对于每层每个节点,如果不是加油站,则从 该点 向 下一层的左边和上边的节点 接一条 <strong>容量为$1$,费用为$B$</strong> 的边(规则2.)</li>
<li>对于每个节点,如果是加油站,则从 第$0$层的该点 按照上两条建边</li>
<li>对于每个节点,如果是加油站,则从 除$0$层外的每层节点 向 第$0$层的该点 接一条 <strong>容量为$1$,费用为$A$</strong> 的边(规则3.)</li>
<li>对于每个节点,如果不是加油站,则从 第$K$层的该点 向 第$0$层的该点 接一条 <strong>容量为$1$,费用为$A+C$</strong> 的边(规则4.)</li>
<li>从 源点 向 第$0$层的$(1, 1)$节点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 每层的$(N, N)$节点 向 汇点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边(到终点不考虑油量)</li>
</ol>
<p>求出最小费用最大流即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.size();</span><br><span class="line">	G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.push(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, A, B, C;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * N + y + dep * N * N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = read(); K = read(); A = read(); B = read(); C = read();</span><br><span class="line">    s = <span class="number">0</span>; n = (K + <span class="number">1</span>) * N * N; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            in[i][j] = read();</span><br><span class="line">            <span class="keyword">if</span> (in[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">                    add(point(i, j, k), point(i, j, <span class="number">0</span>), <span class="number">1</span>, A);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; K; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in[i][j] &amp;&amp; k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N) add(point(i, j, k), point(i + <span class="number">1</span>, j, k + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N) add(point(i, j, k), point(i, j + <span class="number">1</span>, k + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">1</span>) add(point(i, j, k), point(i - <span class="number">1</span>, j, k + <span class="number">1</span>), <span class="number">1</span>, B);</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">1</span>) add(point(i, j, k), point(i, j - <span class="number">1</span>, k + <span class="number">1</span>), <span class="number">1</span>, B);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in[i][j]) add(point(i, j, K), point(i, j, <span class="number">0</span>), <span class="number">1</span>, A + C);</span><br><span class="line">        &#125;</span><br><span class="line">    add(s, point(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">        add(point(N, N, k), t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MinCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」深海机器人问题-题解</title>
    <url>/p/cfb1d422.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4012" target="_blank" rel="noopener">「Luogu P4012」深海机器人问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个$P\times Q$网格,机器人可以向北/东走,西南为$(0, 0)$,东北为$(Q, P)$<br>每个网格边上有生物标本,和价值<br>有$a$个起点,每个起点有不同的机器人个数<br>有$b$个终点,每个终点有不同的机器人个数作为目的地</p>
<p>求采集到生物标本的最高总价值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最大费用最大流</p>
<ol>
<li>每两个节点之间建一条 <strong>容量为$1$,费用为标本价值</strong> 的边,和一条 <strong>容量为$inf$,费用为$0$</strong> 的边(标本只能采集一次)</li>
<li>从 源点 向 每个起点 建一条 <strong>容量为机器人个数,费用为$0$</strong> 的边</li>
<li>从 每个终点 向 汇点 建一条 <strong>容量为机器人个数,费用为$0$</strong> 的边</li>
</ol>
<p>跑出最大费用最大流,最大费用即为结果</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.size();</span><br><span class="line">	G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.push(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p_, q_;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * q_ + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a_ = read(), b_ = read();</span><br><span class="line">    p_ = read() + <span class="number">1</span>; q_ = read() + <span class="number">1</span>;</span><br><span class="line">    s = <span class="number">0</span>, t = p_ * q_ + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p_; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; q_; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = read();</span><br><span class="line">            add(point(i, j), point(i, j + <span class="number">1</span>), <span class="number">1</span>, w);</span><br><span class="line">            add(point(i, j), point(i, j + <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q_; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p_; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = read();</span><br><span class="line">            add(point(j, i), point(j + <span class="number">1</span>, i), <span class="number">1</span>, w);</span><br><span class="line">            add(point(j, i), point(j + <span class="number">1</span>, i), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = read(), x = read() + <span class="number">1</span>, y = read() + <span class="number">1</span>;</span><br><span class="line">        add(s, point(x, y), k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = read(), x = read() + <span class="number">1</span>, y = read() + <span class="number">1</span>;</span><br><span class="line">        add(point(x, y), t, r, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」火星探险问题-题解</title>
    <url>/p/e7256d1.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3356" target="_blank" rel="noopener">「Luogu P3356」火星探险问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$辆车,$p\times q$的网格<br>为0可以通过,1有障碍不能通过,2为岩石可以采集<br>从(1, 1)开始到最右下角,只能向右或向下</p>
<p>求出使到达终点的车最多,而且采集的岩石最多的移动方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每个位置拆成入点和出点</p>
<ol>
<li>如果这个位置是$0$或$2$, 则从 入点 向 出点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
<li>如果这个位置是$2$, 则从 入点 向 出点 接一条 <strong>容量为$1$, 费用为$1$</strong> 的边</li>
<li>如果这个位置$u$的右边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
<li>如果这个位置$u$的下边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
</ol>
<p>跑最大费用最大流,最大流数即到达终点最多的车数<br>输出方案使用dfs,在流量网络中搜索输出路径</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], pre[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.size();</span><br><span class="line">	G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; pre[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				pre[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.push(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[pre[u]].from) &#123;</span><br><span class="line">		edges[pre[u]].flow += a[t];</span><br><span class="line">		edges[pre[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, q;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * p + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> u, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        Edge&amp; ne = edges[G[u][i] ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (e.to == s || e.to == t || e.to == u - n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!e.flow) <span class="keyword">continue</span>;</span><br><span class="line">        e.flow--;</span><br><span class="line">        <span class="keyword">if</span> (e.to &gt; n) &#123;</span><br><span class="line">            dfs(x, y, e.to, id);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nx, ny, dir;</span><br><span class="line">        <span class="keyword">if</span> (e.to == point(x, y) + <span class="number">1</span>) &#123;</span><br><span class="line">            nx = x; ny = y + <span class="number">1</span>;</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nx = x + <span class="number">1</span>; ny = y;</span><br><span class="line">            dir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, id, dir);</span><br><span class="line">        dfs(nx, ny, e.to + n, id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = read(); p = read(); q = read();</span><br><span class="line">    n = p * q; s = <span class="number">0</span>; t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            in[i][j] = read();</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">0</span>) add(point(i, j), point(i, j) + n, inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                add(point(i, j), point(i, j) + n, inf, <span class="number">0</span>);</span><br><span class="line">                add(point(i, j), point(i, j) + n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in[<span class="number">1</span>][<span class="number">1</span>] != <span class="number">1</span>) add(s, <span class="number">1</span>, c, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (in[i][j + <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; j + <span class="number">1</span> &lt;= p) add(point(i, j) + n, point(i, j + <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (in[i + <span class="number">1</span>][j] != <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= q) add(point(i, j) + n, point(i + <span class="number">1</span>, j), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in[q][p] != <span class="number">1</span>) add(point(q, p) + n, t, c, <span class="number">0</span>);</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="comment">// printf("%d %d\n", ansflow, anscost);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ansflow; ++i) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」航空路线问题-题解</title>
    <url>/p/6bb5462a.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2770" target="_blank" rel="noopener">「Luogu P2770」航空路线问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个城市,$n$个点,$v$条边,每个城市有一个名字<br>从西向东按序给出名字<br>求从最西出发到达最东并返回最西(除起点外,每个城市只能访问一次)的路径</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每个城市拆成入点和出点</p>
<ol>
<li>源点为点1的入点,汇点为点n的出点</li>
<li>对于 <strong>除源点汇点</strong> 的每个点, 从 入点 向 出点 建一条 <strong>容量为1,费用为1</strong> 的边(只能经过一次,且对答案贡献为1)</li>
<li>从 点1的入点 向 点1的出点 建一条 <strong>容量为2,费用为1</strong> 的边(可以经过2次,且对答案贡献为1)</li>
<li>从 点n的入点 向 点n的出点 建一条 <strong>容量为2,费用为1</strong> 的边(可以经过2次,且对答案贡献为1)</li>
<li>对于边$&lt;u, v&gt;$, 从 u的出点 向 v的入点 建一条 <strong>容量为1,费用为0</strong> 的边(可经过1次,对答案无贡献)</li>
</ol>
<p>求 <strong>最大费用最大流</strong>, 最大流$maxflow\leq 2$</p>
<ol>
<li>若最大流为$2$, 则会有一条道路, 经过的城市数为最大费用$maxcost-2$(减去重复的源点和汇点的贡献)<br>求路径可以<ul>
<li>先一次dfs找到从1到n的所有残量为0的路径(满流$\mathtt{e.cap == e.flow}$),正序输出</li>
<li>再一次dfs找到另一条满流路径,并用vis确保没有重复城市,倒序输出(不重复输出n)</li>
</ul>
</li>
<li>若最大流为$1$, 则直接从源点到汇点有一条通路, 输出$2$, 路径为$1-&gt;n-&gt;1$</li>
<li>若最大流为$0$, 则无解$\texttt{No Solution!}$</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.size();</span><br><span class="line">	G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.push(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name[u - n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to &lt;= n &amp;&amp; e.cap == e.flow) &#123;</span><br><span class="line">            dfs1(e.to + n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to &lt;= n &amp;&amp; e.cap == e.flow &amp;&amp; !vis[e.to + n]) &#123;</span><br><span class="line">            dfs2(e.to + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name[u - n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    s = <span class="number">1</span>; t = <span class="number">2</span> * n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name[i];</span><br><span class="line">        id[name[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> str1, str2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str2;</span><br><span class="line">        <span class="keyword">int</span> u = id[str1], v = id[str2];</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) swap(u, v);</span><br><span class="line">        add(u + n, v, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        add(i, i + n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    add(s, s + n, <span class="number">2</span>, <span class="number">1</span>); add(n, t, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> maxflow = MinCostMaxFlow(anscost);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxflow == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name[<span class="number">1</span>] &lt;&lt; <span class="string">"\n"</span> &lt;&lt; name[n] &lt;&lt; <span class="string">"\n"</span> &lt;&lt; name[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dfs1(<span class="number">1</span> + n);</span><br><span class="line">    dfs2(<span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」试题库问题-题解</title>
    <url>/p/5a8ce31f.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2763" target="_blank" rel="noopener">「Luogu P2763」试题库问题</a><br><a id="more"></a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>假设一个试题库中有$n$道试题,每道试题都标明了所属类别,同一道题可能有多个类别属性,现要从题库中抽取$m$道题组成试卷,并要求试卷包含指定类型的试题,输出出题方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>建图</strong>: 类型与汇点连容量为题目数的边;题目与源点连容量为$1$的边;题目与所属类型连容量为$1$的边<br><strong>结果</strong>: 如果满流则可以实现(沿满流输出即可),没有满流输出<code>No Solution!</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> k, n, s, t, sum, d[maxn], cur[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn], ansi;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): from(u), to(v), cap(c), flow(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += dfs(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;k, &amp;n);</span><br><span class="line">    s = <span class="number">0</span>; t = n + k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;type);</span><br><span class="line">        sum += type; add(n + i, t, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        add(s, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> p, type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;type);</span><br><span class="line">            add(i, type + n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = MaxFlow(s, t);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == sum) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + k; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d: "</span>, i - n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); ++j) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[i][j]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap == <span class="number">0</span> &amp;&amp; e.flow != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>, e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」负载平衡问题-题解</title>
    <url>/p/b8624866.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4016" target="_blank" rel="noopener">「Luogu P4016」负载平衡问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$个环形的仓库,每个仓库存储一定数量的货物<br>货物可以在相邻仓库之间搬运,最终达到每个仓货物数量一样的效果</p>
<p>求最少搬运次数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看题解说可以用数学方法推导,但是在24题里还是选择用费用流水过</p>
<p>先求出平均数,即目标<br>然后将每个仓库的货物数减去平均数,得出需要移动的数量</p>
<ol>
<li>如果大于$0$,则从 源点 向 该仓库 建一条 <strong>容量为差值,费用为$0$</strong> 的边(需要转移出,对答案无贡献)</li>
<li>如果小于$0$,则从 该仓库 向 汇点 建一条 <strong>容量为差值绝对值,费用为$0$</strong> 的边(吸收这些货物,对答案无贡献)</li>
<li>从 每个仓库 向 相邻两个仓库 建一条 <strong>容量为$inf$,费用为$1$</strong> 的边(转移货物的数量无要求,对答案贡献为$1$)</li>
</ol>
<p>注意建边3.需要考虑环形<br>求出最小费用最大流,最小费用即为结果</p>
<p>因为费用流大前提是满足最大流,而且此图中源点出发的与流入汇点的边的容量和相等,所以最大流情况下一定会全部流过,即达到仓库货物数量平衡</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小费用最大流模板省去了</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">110</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        num[i] = read(); tot += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tot /= n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] - tot &gt; <span class="number">0</span>) add(s, i, num[i] - tot, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (num[i] - tot &lt; <span class="number">0</span>) add(i, t, tot - num[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            add(i, i - <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">            add(i - <span class="number">1</span>, i, inf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add(<span class="number">1</span>, n, inf, <span class="number">1</span>);</span><br><span class="line">    add(n, <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">    ansflow = MinCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」软件补丁问题-题解</title>
    <url>/p/2f9adffb.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2761" target="_blank" rel="noopener">「Luogu P2761」软件补丁问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$n$个错误,$m$个补丁</p>
<p>第$i$个补丁耗时$t_i$<br>使用该补丁需要软件中包含所有$B1_i$中的错误,并且不包含$B2_i$中的任何一个错误<br>该补丁可以修复错误$F1_i$,但会添加错误$F2_i$</p>
<p>找出修复所有错误的最短时间</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>错误较少,可以使用状态压缩,用2进制表示错误的修复情况(1表示未修复,0表示已修复)<br>起始状态$\texttt{111…1}$,结束状态$\texttt{000…0}$</p>
<p>每个状态当做图中的节点,即求起始状态到结束状态的最短路</p>
<p>由于补丁较少,不用连边,在最短路需要遍历边时,遍历所有补丁,并判断是否能够联通(即当前状态是否包含该补丁的$B1$,而不包含$B2$)<br>如果能够连接,则下一个状态为当前状态打上当前补丁(即修复$F1$,添加$F2$)<br>边权为当前补丁的耗时<br>使用SPFA跑最短路即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'+'</span> &amp;&amp; ch != <span class="string">'-'</span> &amp;&amp; ch != <span class="string">'0'</span>) ch = getchar();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'+'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLL</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> b1, b2;</span><br><span class="line">    <span class="keyword">int</span> f1, f2;</span><br><span class="line">&#125;node[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((u &amp; node[i].b1) == node[i].b1 &amp;&amp; (u &amp; node[i].b2) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = ((u | node[i].f1) | node[i].f2) ^ node[i].f1;</span><br><span class="line">                <span class="keyword">if</span> (dis[v] &gt; dis[u] + node[i].time) &#123;</span><br><span class="line">                    dis[v] = dis[u] + node[i].time;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                        q.push(v);</span><br><span class="line">                        vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    s = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        node[i].time = read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sta = read_();</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">1</span>) node[i].b1 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">2</span>) node[i].b2 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sta = read_();</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">2</span>) node[i].f1 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">1</span>) node[i].f2 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[t] == inf ? <span class="number">0</span> : dis[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」运输问题-题解</title>
    <url>/p/152673e9.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4015" target="_blank" rel="noopener">「Luogu P4015」运输问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$m$个仓库,$n$个商店,每个仓库有$a_i$个货物,每个商店需要$b_i$个货物<br>需要从仓库运输货物到商店中,且第$i$个仓库运输到第$j$个商店费用为$c_{i,j}$</p>
<p>求最小费用和最大费用</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>和<a href="http://tony031218.github.io/p/11b1dcbd.html">P4015 分配问题</a>一样<br>将所有仓库和所有商店各分为一个点集</p>
<ol>
<li>从 源点 向 每个仓库 建一条 <strong>容量为货物个数$a_i$,费用为$0$</strong> 的边(有$a_i$个货物需要运出,且对答案无贡献)</li>
<li>从 每个商店 向 汇点 建一条 <strong>容量为货物个数$b_i$,费用为$0$</strong> 的边(需要$b_i$个货物,且对答案无贡献)</li>
<li>从 每个仓库 向 每个商店 建一条 <strong>容量为$inf$,费用为对应费用</strong> 的边(每个仓库可以运出的最多货物不限制,且对答案工作为对应费用)</li>
</ol>
<p>求出最小费用最大流和最大费用最大流即可</p>
<p>由于费用流的大前提是流量最大,所以一定满足题目中要求的供需平衡即$\sum\limits_{i=1}^{m}a_i=\sum\limits_{j=1}^{n}b_j$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 费用流模板省略,在P4015题解那里有</span></span><br><span class="line"><span class="comment">// 代码里为了方便把mn调换了</span></span><br><span class="line"><span class="keyword">int</span> input1[<span class="number">110</span>], input2[<span class="number">110</span>], input3[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    s = <span class="number">0</span>; t = n + m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = read(); input1[i] = c;</span><br><span class="line">        add(s, i, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = read(); input2[i] = c;</span><br><span class="line">        add(i + n, t, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = read(); input3[i][j] = c;</span><br><span class="line">            add(i, j + n, inf, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MinCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line"></span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(s, i, input1[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) add(i + n, t, input2[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            add(i, j + n, inf, input3[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = MaxCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」飞行员配对方案问题-题解</title>
    <url>/p/154ff24f.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2756" target="_blank" rel="noopener">「Luogu P2756」飞行员配对方案数问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>输入两方飞行员个数$m,n$,再给定两方飞行员可以配合的人编号$i,j$(以$-1,-1$结束)<br>输出最多配对数和配对方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>主要在建图<br>皇家空军与源点$s$连容量$1$的边,外籍与汇点$t$连容量$1$的边,可配合的两点间连容量为$1$的边<br>输出最大流即可(要找配对方案)</p>
<p>也可以使用匈牙利算法(本文不给出)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): from(u), to(v), cap(c), flow(f)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.push_back(Edge(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">             Edge&amp; e = edges[G[x][i]];</span><br><span class="line">             <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                 vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                 d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                 Q.push(e.to);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += dfs(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v) == <span class="number">2</span> &amp;&amp; u != <span class="number">-1</span> &amp;&amp; v != <span class="number">-1</span>) &#123;</span><br><span class="line">        add(u, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        add(s, i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        add(i, t, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flow = MaxFlow(s, t);</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[i].from != s &amp;&amp; edges[i].to != t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[i].flow != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, edges[i].from, edges[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」餐巾计划问题-题解</title>
    <url>/p/93562de2.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P1251" target="_blank" rel="noopener">「Luogu P1251」餐巾计划问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>在$N$天里,第$i$天需要$r_i$个餐巾</p>
<ol>
<li>可以购买餐巾,每张$p$元</li>
<li>可以将旧送快洗,$m$天,费用$f$元</li>
<li>可以将旧送慢洗,$n$天,费用$s$元</li>
<li>每天结束,可以送快洗,慢洗,保存</li>
</ol>
<p>设计最小花费</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每天拆成2个点(早晚),新建源点汇点(源点表示获得,汇点表示使用)</p>
<ol>
<li>每天早上的点,向汇点连 <strong>容量为$r_i$,费用为$0$</strong> 的边,表示当日需要使用</li>
<li>源点向每天晚上的点连 <strong>容量为$r_i$,费用为$0$</strong> 的边,每天晚上获得多少旧餐巾</li>
<li>源点向每天早上的点连 <strong>容量为$inf$,费用为$p$</strong> 的边,表示购买</li>
<li>每天晚上向$+m$天的早上连 <strong>容量为$inf$,费用为$f$</strong> 的边,表示快洗</li>
<li>每天晚上向$+n$天的早上连 <strong>容量为$inf$,费用为$s$</strong> 的边,表示快洗</li>
<li>每天晚上向第二天晚上连 <strong>容量为$inf$,费用为$0$</strong> 的边,表示保留</li>
</ol>
<p>跑最小费用最大流</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow, r[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): from(u), to(v), cap(c), flow(f), cost(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.push_back(Edge(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.push_back(Edge(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.size();</span><br><span class="line">	G[u].push_back(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = inf;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = min(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.push(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (BellmanFord(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = read(); s = <span class="number">0</span>; t = <span class="number">2</span> * N + <span class="number">1</span>;</span><br><span class="line">    n = t + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        r[i] = read();</span><br><span class="line">        add(s, i + N, r[i], <span class="number">0</span>);</span><br><span class="line">        add(i, t, r[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pr = read(), t1 = read(), c1 = read(), t2 = read(), c2 = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N) add(i + N, i + N + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + t1 &lt;= N) add(i + N, i + t1, inf, c1);</span><br><span class="line">        <span class="keyword">if</span> (i + t2 &lt;= N) add(i + N, i + t2, inf, c2);</span><br><span class="line">        add(s, i, inf, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    MinCostMaxFlow(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」骑士共存问题-题解</title>
    <url>/p/11da5c27.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3355" target="_blank" rel="noopener">「Luogu P3355」骑士共存问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n\times n$的棋盘,$m$个障碍(骑士不能放置)<br>求最多可以放多少个骑士,不能互相攻击</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先对棋盘进行黑白二染色,$x+y$为奇数和偶数为黑和白,求二分图最大独立集</p>
<ol>
<li>从 源点 向 黑色节点 接一条 <strong>容量为1</strong> 的边</li>
<li>从 白色节点 向 汇点 接一条 <strong>容量为1</strong> 的边</li>
<li>从 每个黑色节点 向 其能攻击到的白色节点接一条 <strong>容量为$inf$</strong> 的边</li>
</ol>
<p>求出最小割即最大流,结果为$\mathtt{n\times n - m - maxflow}$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">8</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.push_back((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.push_back((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.size();</span><br><span class="line">    G[from].push_back(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].push_back(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">        flow += DFS(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> valid[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    s = <span class="number">0</span>; t = n * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        valid[x][y] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!valid[i][j]) &#123;</span><br><span class="line">                    add(s, point(i, j), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!valid[i][j]) &#123;</span><br><span class="line">                    add(point(i, j), t, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!((i + j) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = i + go[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny = j + go[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;= nx &amp;&amp; nx &lt;= n &amp;&amp; <span class="number">1</span> &lt;= ny &amp;&amp; ny &lt;= n &amp;&amp; !valid[nx][ny]) &#123;</span><br><span class="line">                    add(point(i, j), point(nx, ny), inf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = dinic(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n * n - m - maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」魔术球问题-题解</title>
    <url>/p/f2e850c0.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2765" target="_blank" rel="noopener">「Luogu P2765」魔术球问题</a></p>
<a id="more"></a>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>输入柱子数$n$<br>满足如下规则</p>
<ul>
<li>每次只能在某根柱子的最上面放球。</li>
<li>在同一根柱子中，任何2个相邻球的编号之和为完全平方数。<br>输出在第$n$根柱子上最多能放多少球和放置方案</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>并不打算使用网络流,用贪心即可<br><em>贪心策略</em>: <strong>如果可以的话尽可能放在已有的柱子上</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> can[<span class="number">4010</span>];</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">1</span>, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= <span class="number">4000</span>; ++i) &#123;</span><br><span class="line">        can[i * i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can[ ans + a[ i ][ a[i].size() - <span class="number">1</span> ] ]) &#123;</span><br><span class="line">                a[i].push_back(ans++);</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; n) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            a[cnt].push_back(ans++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].size(); ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>带修莫队-笔记/「Luogu P1903」数颜色-题解</title>
    <url>/p/838c5e29.html</url>
    <content><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/P1903" target="_blank" rel="noopener">Luogu P1903 数颜色/维护序列</a>这道题目来学习一下 <strong>带修莫队</strong><br>顾名思义,<strong>带修莫队</strong> 不仅要支持普通莫队的查询操作,还要支持数据中途的修改</p>
<p>比如这道题目,需要实现以下目标</p>
<ol>
<li>查询$[L,R]$区间内不同颜色画笔的种数</li>
<li>将$pos$处的画笔替换为$color$颜色</li>
</ol>
<p>达到这个目标,可以在普通莫队的基础上加一个时间维度,实现 <strong>带修莫队</strong><br><a id="more"></a> </p>
<h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>这里的每个查询的时间戳规定为 <strong>最近修改操作的时间戳</strong>,即最近一次修改是第几次修改<br>修改操作会增加总时间戳,查询操作不会增加时间戳</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>在普通莫队的左右两个指针的基础之上 <em>增加</em> 一个 <strong>时间戳指针</strong><br>当左右端点及时间戳移动到均和当前查询的一致,就可以记录下当前答案</p>
<p>所以需要在普通莫队的基础之上加上修改时间戳的修改操作,并加上以下两个判断<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (t &lt; q[i].t) chg(++t);</span><br><span class="line"><span class="keyword">while</span> (t &gt; q[i].t) chg(t--);</span><br></pre></td></tr></table></figure></p>
<p>当当前时间小于询问时间时,先将当前时间$+1$,再修改<br>当当前时间大于询问时间时,先修改,再将当前时间$-1$</p>
<p>与普通莫队还有一点不同:<br>所有询问的排序方法,先按照左端点分块升序,再按照右端点 <strong>分块升序</strong>,最后按照时间戳升序<br>这样复杂度才会达到最优,节省了一系列不必要的操作</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>当分块的大小为$n^{\frac{2}{3}}$时,复杂度最小为$O(n^{\frac{5}{3}})$<br>具体分析见上一篇文章:<a href="681257d9.html">浅析莫队算法的时间复杂度</a></p>
<h2 id="针对-mathcal-P1903-的具体实现"><a href="#针对-mathcal-P1903-的具体实现" class="headerlink" title="针对$\mathcal{P1903}$的具体实现"></a>针对$\mathcal{P1903}$的具体实现</h2><p>在每个询问<code>Query</code>的结构体内加一个时间戳$t$,并且按照上文实现排序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block[a.l] != block[b.l]) <span class="keyword">return</span> block[a.l] &lt; block[b.l];</span><br><span class="line">    <span class="keyword">if</span> (block[a.r] != block[b.r]) <span class="keyword">return</span> block[a.r] &lt; block[b.r];</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再建一个结构体<code>Change</code>,表示每次修改操作的数据,需要$pos$和$color$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, color;</span><br><span class="line">&#125;c[maxn];</span><br></pre></td></tr></table></figure></p>
<p>正常的<code>add/del</code>操作不再赘述<br>现在来看一下修改时间对应数据的操作</p>
<ol>
<li>当当前时间的操作的位置$pos$在当前区间$[l,r]$时,对答案有影响,需要调整当前答案<br>先将$pos$位置上的贡献删去,再将当前修改操作的$color$添加进去</li>
<li>将$pos$位置上的数与$color$交换,这样可以保证之后可以再换回来</li>
</ol>
<p>实现如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[a[c[t].pos]] == <span class="number">0</span>) Ans--; <span class="comment">// 删除贡献</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[c[t].color]++  == <span class="number">0</span>) Ans++; <span class="comment">// 添加贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[c[t].pos], c[t].color); <span class="comment">// 交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外这题修改数据后严重卡常,手动开了O3,Ofast,inline才过</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">140000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, t, len, cntq, cntr, Ans;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[<span class="number">1000010</span>], ans[maxn], block[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block[a.l] != block[b.l]) <span class="keyword">return</span> block[a.l] &lt; block[b.l];</span><br><span class="line">    <span class="keyword">if</span> (block[a.r] != block[b.r]) <span class="keyword">return</span> block[a.r] &lt; block[b.r];</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, color;</span><br><span class="line">&#125;c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == <span class="number">0</span>) Ans++;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == <span class="number">1</span>) Ans--;</span><br><span class="line">    cnt[a[x]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) &#123;</span><br><span class="line">        del(c[t].pos);</span><br><span class="line">        <span class="keyword">if</span> (cnt[c[t].color] == <span class="number">0</span>) Ans++;</span><br><span class="line">        cnt[c[t].color]++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[c[t].pos], c[t].color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read(); len = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">        block[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt[<span class="number">10</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            q[++cntq].l = read(); q[cntq].r = read();</span><br><span class="line">            q[cntq].id = cntq; q[cntq].t = cntr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[++cntr].pos = read();</span><br><span class="line">            c[cntr].color = read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + <span class="number">1</span> + cntq, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) del(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) del(r--);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) add(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) add(++r);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q[i].t) chg(++t);</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q[i].t) chg(t--);</span><br><span class="line">        ans[q[i].id] = Ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>题解</tag>
        <tag>NOIp</tag>
        <tag>莫队</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志</title>
    <url>/p/5a717bf0.html</url>
    <content><![CDATA[<p><a href="https://tony031218.github.io/">本博客</a>在<code>2019.3.10</code>更改至由<code>Hexo</code>驱动，并在<code>2019.3.12</code>完成更改。<br>原文章时间均改为<code>2019.1.9</code>，算法模板时间改为<code>2019.1.10</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>浅析莫队算法的时间复杂度</title>
    <url>/p/681257d9.html</url>
    <content><![CDATA[<p>这篇文章来记录一下莫队算法时间复杂度的简单(<del>不严谨</del>)计算</p>
<p>首先分析一下莫队算法的时间复杂度有哪些方面构成</p>
<ol>
<li>对询问<code>Query</code>数组的排序</li>
<li>区间左指针的移动</li>
<li>区间右指针的移动<a id="more"></a> 
</li>
</ol>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>每个<code>add/del</code>操作的复杂度为$O(1)$</p>
<ol>
<li>排序使用<code>sort</code>可以在$O(n\log n)$内完成</li>
<li><p>由于左指针在排序中被分块,所以又分为块内移动和块间移动</p>
<ul>
<li><strong>块内</strong>: 设每块中含左端点$x_i$个,由于每块大小为$\sqrt{n}$,所以在块内移动的最坏复杂度为$O(x_i\sqrt{n})$。<br>因此对于所有块,将复杂度求和,即为$O(\displaystyle\sum_ix_i\sqrt{n})=O(n\sqrt{n})$</li>
<li><strong>块间</strong>: 左指针在每个块内移动之后,需要移动到下一个块内的左端点处,块间跳转最坏跨两个整块需要$O(2\sqrt{n})$。<br>总共需要跨$\sqrt{n}-1$个块,所以复杂度为$O((\sqrt{n}-1)\times 2\sqrt{n})\sim O(n)$</li>
</ul>
</li>
</ol>
<p>综上,左指针移动的复杂度为$O(n\sqrt{n})$</p>
<ol start="3">
<li>当左指针在同一个块内时,右指针是有序的,因此当左指针在同一个块内时,右指针移动的最坏复杂度为$O(n)$即全部移动一遍。而每个块长度为$\sqrt{n}$,总长为$n$,所以一共$\sqrt{n}$个块,所以最坏复杂度为$O(n\sqrt{n})$</li>
</ol>
<p>综上,普通莫队算法的时间复杂度为<br>$$<br>O(n\log n)+O(n\sqrt{n})+O(n\sqrt{n})\ \sim\ O(n\sqrt{n})<br>$$</p>
<h2 id="玄学的奇偶排序优化"><a href="#玄学的奇偶排序优化" class="headerlink" title="玄学的奇偶排序优化"></a><del>玄学</del>的奇偶排序优化</h2><p>见图:<br><img src="/p/681257d9/MosAlgoCompare.png" alt="左:无奇偶排序,右:有奇偶排序&lt;/br&gt;图中灰色虚线表示分块的边界;带端点的线段表示需要询问的区间;红色箭头表示两种方法右指针移动相同长度的部分;蓝色箭头表示不同的部分。可以看出,有奇偶排序的蓝色箭头变短,避免了无意义的大幅度跳动,节省了一些常数复杂度"></p>
<h2 id="分块大小不为-sqrt-n"><a href="#分块大小不为-sqrt-n" class="headerlink" title="分块大小不为$\sqrt{n}$"></a>分块大小不为$\sqrt{n}$</h2><p>还是和前面一样推复杂度,设块大小为$a&gt;1$</p>
<ol>
<li><strong>排序</strong>: 需要$O(n\log n)$</li>
<li><strong>左指针移动</strong>: <ul>
<li><strong>块内</strong>: $O(\displaystyle\sum_ix_ia)=O(na)$</li>
<li><strong>块间</strong>: $O((\dfrac{n}{a}-1)\times 2a)=O(n)$</li>
</ul>
</li>
<li><strong>右指针移动</strong>: $O(n\times \dfrac{n}{a})=O(\dfrac{n^2}{a})$</li>
</ol>
<p>综上,总的复杂度为$O(n\log n)+O(na)+O(n)+O(\dfrac{n^2}{a})=O(na+\dfrac{n^2}{a})$<br>根据均值不等式,若让上式复杂度最小,则需要$na=\dfrac{n^2}{a}$,即$a=\sqrt{n}$<br>所以当含有左右两个指针时,分块大小为$\sqrt{n}$时总复杂度最小,为$O(n\sqrt{n})$</p>
<h2 id="带修莫队-三指针"><a href="#带修莫队-三指针" class="headerlink" title="带修莫队(三指针)"></a>带修莫队(三指针)</h2><p>还是设分块的大小为$a&gt;1$,注意带修莫队排序优先级:先左端点所在块,再右端点所在块,后时间戳大小</p>
<ol>
<li><strong>排序</strong>: $O(n\log n)$</li>
<li><strong>左指针移动</strong>: 同上推导,复杂度为$O(na)$</li>
<li><strong>右指针移动</strong>: 相同右端点的块的复杂度同上$O(na)$,还有换左端点决定的块时的复杂度约为$O(\dfrac{n^2}{a})$</li>
<li><strong>时间戳移动</strong>: 由排序优先级可见,只有当右端点所在块相同时才会移动时间戳,而每次移动最坏需要移动$\sum t \sim n$<br>对于每个左端点相同的块,右端点块数为$\dfrac{n}{a}$,左端点有$\dfrac{n}{a}$个,所以一共需要$O(\dfrac{n}{a}\times\dfrac{n}{a}\times n)=O(\dfrac{n^3}{a^2})$</li>
</ol>
<p>综上,总的复杂度为$O(n\log n)+O(na)+O(na)+O(\dfrac{n^2}{a})+O(\dfrac{n^3}{a^2})\ \sim\  O(na+\dfrac{n^2}{a}+\dfrac{n^3}{a^2})$</p>
<p>由于$1&lt;a&lt;n$,所以$\dfrac{\dfrac{n^2}{a}}{\dfrac{n^3}{a^2}}=\dfrac{a}{n}&lt;1 \Rightarrow \dfrac{n^2}{a}&lt;\dfrac{n^3}{a^2}$,所以原式可化为$O(na+\dfrac{n^3}{a^2})$</p>
<p>根据均值不等式,当$na=\dfrac{n^3}{a^2}$时上式最小,即$a=\sqrt[3]{n^2}=n^{\frac{2}{3}}$<br>所以含有三个指针时,分块大小为$n^{\frac{2}{3}}$时总复杂度最小,为$O(n^{\frac{5}{3}})=O(n\sqrt[3]{n^2})$</p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记-数论</title>
    <url>/p/da9a11f.html</url>
    <content><![CDATA[<p>模板地址: <a href="https://github.com/Tony031218/luogu/blob/master/Mathematics.cpp" target="_blank" rel="noopener">GitHub</a></p>
<h2 id="欧几里得算法-Euclid-algorithm"><a href="#欧几里得算法-Euclid-algorithm" class="headerlink" title="欧几里得算法(Euclid algorithm)"></a>欧几里得算法(Euclid algorithm)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lcm(a, b) = a / gcd(a, b) * b</code></p>
<h3 id="扩展欧几里得算法-exGCD"><a href="#扩展欧几里得算法-exGCD" class="headerlink" title="扩展欧几里得算法(exGCD)"></a>扩展欧几里得算法(exGCD)</h3><p><strong><em>目标</em></strong>: 寻找一对整数$(x, y)$,使$ax+by=gcd(a,b)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123; d = a; x = <span class="number">1</span>; y = <span class="number">0</span>; &#125;  <span class="comment">//d为gcd(a, b)</span></span><br><span class="line">    <span class="keyword">else</span> &#123; exgcd(b, a % b, d, y, x); y -= x * (a / b); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h4><p>$ax+by=c$且$x,y$全为正整数,则当且仅当$gcd(a, b)|c$</p>
<h2 id="素数相关"><a href="#素数相关" class="headerlink" title="素数相关"></a>素数相关</h2><h3 id="Eratosthenes筛法"><a href="#Eratosthenes筛法" class="headerlink" title="Eratosthenes筛法"></a>Eratosthenes筛法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>), num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        prime[++num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j += i) vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性筛"><a href="#欧拉线性筛" class="headerlink" title="欧拉线性筛"></a>欧拉线性筛</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i * prime[j];</span><br><span class="line">            <span class="keyword">if</span> (v &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h3><p>$$<br>\pi(x) \sim \frac{x}{\ln x}<br>$$</p>
<h3 id="Miller-Rabin-素数测试"><a href="#Miller-Rabin-素数测试" class="headerlink" title="$Miller-Rabin$素数测试"></a>$Miller-Rabin$素数测试</h3><p><strong><em>原理</em></strong>:费马小定理<br>若$a^{n-1}\equiv 1\pmod n$,$a$取值越多,可以近似认为$n$为质数<br>使用二次探测定理改进卡卡迈尔数(合数$n$对于任何正整数$b$,都满足$gcd(b, n)=1\ \ b^{n-1}\equiv 1\pmod n$)的bug<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Random</span><span class="params">(LL n)</span> </span>&#123; <span class="keyword">return</span> (LL)((<span class="keyword">double</span>)rand() / RAND_MAX * n + <span class="number">0.5</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Witness</span><span class="params">(LL a, LL n)</span> </span>&#123;</span><br><span class="line">    LL m = n - <span class="number">1</span>; <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(m &amp; <span class="number">1</span>)) &#123; j++; m &gt;&gt;= <span class="number">1</span>; &#125;</span><br><span class="line">    LL x = pow_mod(a, m, n);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123; x = x * x % n; <span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        LL a = Random(n - <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Witness(a, n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模算术"><a href="#模算术" class="headerlink" title="模算术"></a>模算术</h2><p>$$<br>(a + b)\bmod n = ((a\bmod n) + (b\bmod n))\bmod n\\<br>(a - b)\bmod n = ((a\bmod n) - (b\bmod n) + n)\bmod n\\<br>ab\mod n = (a\bmod n)(b\bmod n)\bmod n<br>$$</p>
<h3 id="快速乘-ab-bmod-n"><a href="#快速乘-ab-bmod-n" class="headerlink" title="快速乘 $ab\bmod n$"></a>快速乘 $ab\bmod n$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul_mod</span><span class="params">(LL a, LL b, LL n)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = (res + a) % n;</span><br><span class="line">        a = (a + a) % n;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂-a-p-bmod-n"><a href="#快速幂-a-p-bmod-n" class="headerlink" title="快速幂 $a^p\bmod n$"></a>快速幂 $a^p\bmod n$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL a, LL p, LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL ans = pow_mod(a, p / <span class="number">2</span>, n); ans = ans * ans % n;</span><br><span class="line">    <span class="keyword">if</span> (p % <span class="number">2</span> == <span class="number">1</span>) ans = ans * a % n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用位运算:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL a, LL p, LL n)</span> </span>&#123;</span><br><span class="line">    a %= n; LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>, a *= a, a %= n) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a % n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="欧拉-varphi-函数"><a href="#欧拉-varphi-函数" class="headerlink" title="欧拉$\varphi$函数"></a>欧拉$\varphi$函数</h2><p>$$\varphi(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})$$<br>$\varphi(n)$表示不超过$n$且与$n$互质的整数个数</p>
<h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>); <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛欧拉函数表"><a href="#筛欧拉函数表" class="headerlink" title="筛欧拉函数表"></a>筛欧拉函数表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) phi[i] = <span class="number">0</span>; phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!phi[i])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">            phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同余式定理"><a href="#同余式定理" class="headerlink" title="同余式定理"></a>同余式定理</h2><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若$gcd(a, n) = 1$,则$a^{\varphi(n)}\equiv 1\pmod n$</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若$p$为质数,则$a^{p-1}\equiv 1\pmod p$</p>
<h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><p>若$p$为质数,则$(p-1)!\equiv -1\pmod p$</p>
<h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><p>$$a\div b\bmod n = a\times b^{-1}\bmod n$$<br>$b^{-1}$称为$b$在模$n$意义下的逆元</p>
<h3 id="n-为质数"><a href="#n-为质数" class="headerlink" title="$n$为质数"></a>$n$为质数</h3><p>使用费马小定理, $a^{-1} = a^{n - 2}$</p>
<h3 id="n-不为质数"><a href="#n-不为质数" class="headerlink" title="$n$不为质数"></a>$n$不为质数</h3><p>递归求解<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL n)</span> </span>&#123;</span><br><span class="line">    LL d, x, y;</span><br><span class="line">    exgcd(a, n, d, x, y);</span><br><span class="line">    <span class="keyword">return</span> d == <span class="number">1</span> ? (x + n) % n : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="筛逆元表"><a href="#筛逆元表" class="headerlink" title="筛逆元表"></a>筛逆元表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> inv_table[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinv</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    inv_table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        inv_table[i] = (LL)(p - p / i) * inv_table[p % i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h2><p>$ax\equiv b\pmod n$可以化为$ax+ny=b$使用扩展欧拉定理解决</p>
<h3 id="中国剩余定理-China-Remainder-Theorem"><a href="#中国剩余定理-China-Remainder-Theorem" class="headerlink" title="中国剩余定理(China Remainder Theorem)"></a>中国剩余定理(China Remainder Theorem)</h3><p>求解$x\equiv a_i\pmod {m_i}$满足$m_i$两两互质<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">crt</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* a, <span class="keyword">int</span>* m)</span> </span>&#123;</span><br><span class="line">    LL M = <span class="number">1</span>, d, y, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) M *= m[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        LL w = M / m[i];</span><br><span class="line">        exgcd(m[i], w, d, d, y);</span><br><span class="line">        x = (x + y * w * a[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="扩展中国剩余定理-exCRT"><a href="#扩展中国剩余定理-exCRT" class="headerlink" title="扩展中国剩余定理(exCRT)"></a>扩展中国剩余定理(exCRT)</h4><p>$m_i$不一定两两互质<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">excrt</span><span class="params">(LL n, LL* a, LL* m)</span> </span>&#123;</span><br><span class="line">    LL x, y, k, M = m[<span class="number">0</span>], ans = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        LL A = M, B = m[i], C = (a[i] - ans % B + B) % B, gcd;</span><br><span class="line">        exgcd(A, B, gcd, x, y);</span><br><span class="line">        LL bg = B / gcd;</span><br><span class="line">        <span class="keyword">if</span> (C % gcd != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x = mul_mod(x, C / gcd, bg);</span><br><span class="line">        ans += x * M; M *= bg;</span><br><span class="line">        ans = (ans % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="离散对数-BSGS"><a href="#离散对数-BSGS" class="headerlink" title="离散对数(BSGS)"></a>离散对数(BSGS)</h3><p>求解$a^x\equiv b\pmod n$满足$n$为质数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_mod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, v, e = <span class="number">1</span>, i;</span><br><span class="line">    m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">    v = inv(pow_mod(a, m, n), n);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x;</span><br><span class="line">    x[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        e = mul_mod(e, a, n);</span><br><span class="line">        <span class="keyword">if</span> (!x.count(e)) x[e] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.count(b)) <span class="keyword">return</span> i * m + x[b];</span><br><span class="line">        b = mul_mod(b, v, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h3><p>整除分块可以对后面的莫比乌斯反演提供很大的优化<br>通过<del>枚举</del>可以发现$\lfloor \frac{n}{i} \rfloor$的结果会出现分块现象<br>例如$n=10$时<br>$\ \ \ i\ \ \ \ 1\ \ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10\ 11\ 12\ 13\ …$<br>$\lfloor \frac{n}{i} \rfloor\ 10\ 5\ 3\ 2\ 2\ 1\ 1\ 1\ 1\ 1\ \ \ 0\ \ \ 0\ \ \ 0\ \ \ …$<br><del>不难发现</del>,每个块的右端点为$r=\lfloor \frac{n}{t}\rfloor (t=\lfloor \frac{n}{i}\rfloor)$</p>
<h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p>$$<br>\mu(n) =<br>\begin{cases}<br>1,  &amp; n=1 \\<br>(-1)^r, &amp; n=p_1p_2p_3…p_r(\text{$p_i$为互不相同的质数}) \\<br>0,  &amp; else<br>\end{cases}<br>$$<br><strong><em>性质</em></strong>:<br>$$\sum_{d|n}{\mu(d)}=[n=1]$$<br>$$\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\varphi(n)}{n}$$<br><strong><em>线性筛</em></strong>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn], vis[maxn];</span><br><span class="line"><span class="keyword">int</span> primes[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(mu, <span class="number">0</span>, <span class="keyword">sizeof</span>(mu));</span><br><span class="line">	cnt = <span class="number">0</span>; mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123; primes[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; primes[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">			vis[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">			mu[i * primes[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记-计算几何</title>
    <url>/p/1aba30fe.html</url>
    <content><![CDATA[<p>啥也不说了,直接上代码,每个函数功能已经以注释方式给出</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> *  &gt; Description      : 计算几何模板</span></span><br><span class="line"><span class="comment"> *  &gt; Copyright (C) 2019 Tony</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;     <span class="comment">//精度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI  = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点(向量)</span></span><br><span class="line"><span class="comment"> * @param x 横坐标</span></span><br><span class="line"><span class="comment"> * @param y 纵坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>): x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line">Vector <span class="keyword">operator</span> + (Vector a, Vector b) &#123; <span class="keyword">return</span> Vector(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Vector a, Vector b) &#123; <span class="keyword">return</span> Vector(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> * (Vector a, <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> Vector(a.x * p, a.y * p); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> / (Vector a, <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> Vector(a.x / p, a.y / p); &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 带精度比较(三态函数)</span></span><br><span class="line"><span class="comment"> * @param[in]  x  输入</span></span><br><span class="line"><span class="comment"> * @return 大小关系：等于0(0), 小于零(-1), 大于零(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(a.x - b.x) == <span class="number">0</span> &amp;&amp; dcmp(a.y - b.y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.x + a.y * b.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span><span class="params">(Vector a)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(Dot(a, a)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">acos</span>(Dot(a, b) / Length(a) / Length(b)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.y - a.y * b.x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Area2</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123; <span class="keyword">return</span> Cross(b - a, c - a); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dist2</span><span class="params">(<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B)</span> </span>&#123; <span class="keyword">return</span> (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">angle</span><span class="params">(Vector v)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(v.y, v.x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向量旋转</span></span><br><span class="line"><span class="comment"> * @param[in]  a    向量</span></span><br><span class="line"><span class="comment"> * @param[in]  rad  旋转角度(逆时针)</span></span><br><span class="line"><span class="comment"> * @return 旋转后的向量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector a, <span class="keyword">double</span> rad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Vector(a.x * <span class="built_in">cos</span>(rad) - a.y * <span class="built_in">sin</span>(rad), a.x * <span class="built_in">sin</span>(rad) + a.y * <span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求单位向量</span></span><br><span class="line"><span class="comment"> * @param[in]  a  向量</span></span><br><span class="line"><span class="comment"> * @return 沿向量a的单位向量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Vector <span class="title">Normal</span><span class="params">(Vector a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> L = Length(a);</span><br><span class="line">    <span class="keyword">return</span> Vector(-a.y / L, a.x / L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两条直线交点</span></span><br><span class="line"><span class="comment"> * @param[in]  p  第一条直线的起始点</span></span><br><span class="line"><span class="comment"> * @param[in]  v  第一条直线的方向向量</span></span><br><span class="line"><span class="comment"> * @param[in]  q  第二条直线的起始点</span></span><br><span class="line"><span class="comment"> * @param[in]  w  第二条直线的方向向量</span></span><br><span class="line"><span class="comment"> * @return 两条直线交点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Point p, Vector v, Point q, Vector w)</span> </span>&#123;</span><br><span class="line">    Vector u = p - q;</span><br><span class="line">    <span class="keyword">double</span> t = Cross(w, u) / Cross(v, w);</span><br><span class="line">    <span class="keyword">return</span> p + v * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点到直线距离</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  直线上两点</span></span><br><span class="line"><span class="comment"> * @return 点到直线距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToLine</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    Vector v1 = b - a, v2 = p - a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(Cross(v1, v2)) / Length(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点到线段距离</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  线段两端点</span></span><br><span class="line"><span class="comment"> * @return 点到线段距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToSegment</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> Length(p - a);</span><br><span class="line">    Vector v1 = b - a, v2 = p - a, v3 = p - b;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(Dot(v1, v2)) &lt; <span class="number">0</span>) <span class="keyword">return</span> Length(v2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dcmp(Dot(v1, v3)) &gt; <span class="number">0</span>) <span class="keyword">return</span> Length(v3);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fabs</span>(Cross(v1, v2)) / Length(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点在直线上投影点</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  直线上两点</span></span><br><span class="line"><span class="comment"> * @return 点在直线上投影点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineProjection</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    Vector v = b - a;</span><br><span class="line">    <span class="keyword">return</span> a + v * (Dot(v, p - a) / Dot(v, v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线段相交判定(不含端点)</span></span><br><span class="line"><span class="comment"> * @param[in]  a1,a2  第一条线段端点</span></span><br><span class="line"><span class="comment"> * @param[in]  b1,b2  第二条线段端点</span></span><br><span class="line"><span class="comment"> * @return 是否相交(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SegmentProperIntersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),</span><br><span class="line">           c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(c3) * dcmp(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点在线段上判定(不包括端点)</span></span><br><span class="line"><span class="comment"> * @param[in]  p      点</span></span><br><span class="line"><span class="comment"> * @param[in]  a1,a2  线段两端点</span></span><br><span class="line"><span class="comment"> * @return 是否在线段上(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(Cross(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 多边形面积</span></span><br><span class="line"><span class="comment"> * @param[in]  *p  顶点数组</span></span><br><span class="line"><span class="comment"> * @param[in]</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolygonArea</span><span class="params">(Point* p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        area += Cross(p[i] - p[<span class="number">0</span>], p[i + <span class="number">1</span>] - p[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 直线(参数式)</span></span><br><span class="line"><span class="comment"> * @param p   直线上的一点</span></span><br><span class="line"><span class="comment"> * @param v   方向向量</span></span><br><span class="line"><span class="comment"> * @param ang 方向向量极角</span></span><br><span class="line"><span class="comment"> * @function point(double t)</span></span><br><span class="line"><span class="comment"> *     @brief        直线上的点</span></span><br><span class="line"><span class="comment"> *     @param[in] t  横坐标</span></span><br><span class="line"><span class="comment"> *     @return       直线上的点</span></span><br><span class="line"><span class="comment"> * @function move(double d)</span></span><br><span class="line"><span class="comment"> *     @brief        沿直线移动</span></span><br><span class="line"><span class="comment"> *     @param[in] d  平移距离</span></span><br><span class="line"><span class="comment"> *     @return       平移后的直线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point p;</span><br><span class="line">    Vector v;</span><br><span class="line">    <span class="keyword">double</span> ang;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point p, Vector v): p(p), v(v) &#123; ang = <span class="built_in">atan2</span>(v.y, v.x); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Line&amp; L) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ang &lt; L.ang;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p + v * t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Line <span class="title">move</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Line(p + Normal(v) * d, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 是否在直线左侧</span></span><br><span class="line"><span class="comment"> * @param[in]  L  直线</span></span><br><span class="line"><span class="comment"> * @param[in]  p  点</span></span><br><span class="line"><span class="comment"> * @return 是否在点左侧(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnLeft</span><span class="params">(Line L, Point p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Cross(L.v, p - L.p) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两条直线交点(重载)</span></span><br><span class="line"><span class="comment"> * @param[in]  a  第一条直线</span></span><br><span class="line"><span class="comment"> * @param[in]  b  第二条直线</span></span><br><span class="line"><span class="comment"> * @return 两条直线交点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    Vector u = a.p - b.p;</span><br><span class="line">    <span class="keyword">double</span> t = Cross(b.v, u) / Cross(a.v, b.v);</span><br><span class="line">    <span class="keyword">return</span> a.p + a.v * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 圆</span></span><br><span class="line"><span class="comment"> * @param c   圆心</span></span><br><span class="line"><span class="comment"> * @param r   半径</span></span><br><span class="line"><span class="comment"> * @function point(double a)</span></span><br><span class="line"><span class="comment"> *     @brief         圆上的点</span></span><br><span class="line"><span class="comment"> *     @param[in]  a  横坐标</span></span><br><span class="line"><span class="comment"> *     @return        圆上的点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    Point c;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    Circle(Point c, <span class="keyword">double</span> r): c(c), r(r) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(c.x + <span class="built_in">cos</span>(a) * r, c.y + <span class="built_in">sin</span>(a) * r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 直线和圆交点</span></span><br><span class="line"><span class="comment"> * @param[in]   L      直线</span></span><br><span class="line"><span class="comment"> * @param[in]   C      圆</span></span><br><span class="line"><span class="comment"> * @param[out]  t1,t2  交点横坐标</span></span><br><span class="line"><span class="comment"> * @param[out]  sol    交点集(vector)</span></span><br><span class="line"><span class="comment"> * @return 交点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLineCircleIntersection</span><span class="params">(Line L, Circle C, <span class="keyword">double</span>&amp; t1, <span class="keyword">double</span>&amp; t2, <span class="built_in">vector</span>&lt;Point&gt;&amp; sol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line">    <span class="keyword">double</span> e = a * a + c * c, f = <span class="number">2</span> * (a * b + c * d), g = b * b + d * d - C.r * C.r;</span><br><span class="line">    <span class="keyword">double</span> delta = f * f - <span class="number">4</span> * e * g;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(delta) &lt; <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(delta) == <span class="number">0</span>) &#123;</span><br><span class="line">        t1 = t2 = -f / (<span class="number">2</span> * e);</span><br><span class="line">        sol.push_back(L.point(t1));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = (-f - <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span> * e); sol.push_back(L.point(t1));</span><br><span class="line">    t2 = (-f + <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span> * e); sol.push_back(L.point(t2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 圆和圆交点</span></span><br><span class="line"><span class="comment"> * @param[in]   C1,C2  两圆</span></span><br><span class="line"><span class="comment"> * @param[out]  sol    交点集(vector)</span></span><br><span class="line"><span class="comment"> * @return 交点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCircleCircleIntersection</span><span class="params">(Circle C1, Circle C2, <span class="built_in">vector</span>&lt;Point&gt;&amp; sol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = Length(C1.c - C2.c);</span><br><span class="line">    <span class="keyword">if</span> (dcmp(d) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dcmp(C1.r - C2.r) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(C1.r + C2.r - d) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(<span class="built_in">fabs</span>(C1.r - C2.r) - d) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> a = angle(C2.c - C1.c);</span><br><span class="line">    <span class="keyword">double</span> da = <span class="built_in">acos</span>((C1.r * C1.r + d * d - C2.r * C2.r) / (<span class="number">2</span> * C1.r * d));</span><br><span class="line">    Point p1 = C1.point(a - da), p2 = C1.point(a + da);</span><br><span class="line">    sol.push_back(p1);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    sol.push_back(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求切线</span></span><br><span class="line"><span class="comment"> * @param[in]   p   点</span></span><br><span class="line"><span class="comment"> * @param[in]   C   圆</span></span><br><span class="line"><span class="comment"> * @param[out]  *v  切线</span></span><br><span class="line"><span class="comment"> * @return 切线条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Point p, Circle C, Vector* v)</span> </span>&#123;</span><br><span class="line">    Vector u = C.c - p;</span><br><span class="line">    <span class="keyword">double</span> dist = Length(u);</span><br><span class="line">    <span class="keyword">if</span> (dist &lt; C.r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dcmp(dist - C.r) == <span class="number">0</span>) &#123;</span><br><span class="line">        v[<span class="number">0</span>] = Rotate(u, PI / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">asin</span>(C.r / dist);</span><br><span class="line">        v[<span class="number">0</span>] = Rotate(u, -ang);</span><br><span class="line">        v[<span class="number">1</span>] = Rotate(u, +ang);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两圆公切线</span></span><br><span class="line"><span class="comment"> * @param[in]   A,B    两圆</span></span><br><span class="line"><span class="comment"> * @param[out]  *a,*b  切点</span></span><br><span class="line"><span class="comment"> * @return 公切线条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Circle A, Circle B, Point* a, Point* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (A.r - B.r) &#123; swap(A, B); swap(a, b); &#125;</span><br><span class="line">    <span class="keyword">int</span> d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y);</span><br><span class="line">    <span class="keyword">int</span> rdiff = A.r - B.r;</span><br><span class="line">    <span class="keyword">int</span> rsum  = A.r + B.r;</span><br><span class="line">    <span class="keyword">if</span> (d2 &lt; rdiff * rdiff) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> base = <span class="built_in">atan2</span>(B.c.y - A.c.y, B.c.x - A.c.x);</span><br><span class="line">    <span class="keyword">if</span> (d2 == <span class="number">0</span> &amp;&amp; A.r == B.r) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d2 == rdiff * rdiff) &#123;</span><br><span class="line">        a[cnt] = A.point(base);</span><br><span class="line">        b[cnt] = B.point(base);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r - B.r) / <span class="built_in">sqrt</span>(d2));</span><br><span class="line">    a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); cnt++;</span><br><span class="line">    a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); cnt++;</span><br><span class="line">    <span class="keyword">if</span> (d2 == rsum * rsum) &#123;</span><br><span class="line">        a[cnt] = A.point(base);</span><br><span class="line">        b[cnt] = B.point(PI + base);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d2 &gt; rsum * rsum) &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r + B.r) / <span class="built_in">sqrt</span>(d2));</span><br><span class="line">        a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt++;</span><br><span class="line">        a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判定点在多边形内</span></span><br><span class="line"><span class="comment"> * @param[in]  p     点</span></span><br><span class="line"><span class="comment"> * @param[in]  poly  多边形</span></span><br><span class="line"><span class="comment"> * @return 是否在多边形内(在1,不在0,在边上-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, Polygon poly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = poly.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (OnSegment(p, poly[i], poly[(i + <span class="number">1</span>) % n])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = dcmp(Cross(poly[(i + <span class="number">1</span>) % n] - poly[i], p - poly[i]));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(poly[i].y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(poly[(i + <span class="number">1</span>) % n].y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 凸包</span></span><br><span class="line"><span class="comment"> * @param[in]  p  点集</span></span><br><span class="line"><span class="comment"> * @return 凸包多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Polygon <span class="title">ConvexHull</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">    sort(p.begin(), p.end());</span><br><span class="line">    p.erase(unique(p.begin(), p.end()), p.end());</span><br><span class="line">    <span class="keyword">int</span> n = p.size();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Polygon <span class="title">ch</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">1</span> &amp;&amp; Cross(ch[m - <span class="number">1</span>] - ch[m - <span class="number">2</span>], p[i] - ch[m - <span class="number">2</span>]) &lt;= <span class="number">0</span>) m--;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; k &amp;&amp; Cross(ch[m - <span class="number">1</span>] - ch[m - <span class="number">2</span>], p[i] - ch[m - <span class="number">2</span>]) &lt;= <span class="number">0</span>) m--;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) m--;</span><br><span class="line">    ch.resize(m);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 旋转卡壳</span></span><br><span class="line"><span class="comment"> * @param[in]  points  点集</span></span><br><span class="line"><span class="comment"> * @return 直径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameter2</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123; <span class="comment">//旋转卡壳</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; p = ConvexHull(points);</span><br><span class="line">    <span class="keyword">int</span> n = p.size();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> Dist2(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">    p.push_back(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>, v = <span class="number">1</span>; u &lt; n; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = Cross(p[u + <span class="number">1</span>] - p[u], p[v + <span class="number">1</span>] - p[v]);</span><br><span class="line">            <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans = max(ans, (<span class="keyword">int</span>)Dist2(p[u], p[v]));</span><br><span class="line">                <span class="keyword">if</span> (diff == <span class="number">0</span>) ans = max(ans, (<span class="keyword">int</span>)Dist2(p[u], p[v + <span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v = (v + <span class="number">1</span>) % n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 切多边形</span></span><br><span class="line"><span class="comment"> * @param[in]  poly  多边形</span></span><br><span class="line"><span class="comment"> * @param[in]  A,B   直线上两点</span></span><br><span class="line"><span class="comment"> * @return 新多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Polygon <span class="title">CutPolygon</span><span class="params">(Polygon poly, Point A, Point B)</span> </span>&#123;</span><br><span class="line">    Polygon newpoly;</span><br><span class="line">    <span class="keyword">int</span> n = poly.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Point C = poly[i];</span><br><span class="line">        Point D = poly[(i + <span class="number">1</span>) % n];</span><br><span class="line">        <span class="keyword">if</span> (dcmp(Cross(B - A, C - A)) &gt;= <span class="number">0</span>) newpoly.push_back(C);</span><br><span class="line">        <span class="keyword">if</span> (dcmp(Cross(B - A, C - D)) != <span class="number">0</span>) &#123;</span><br><span class="line">            Point ip = GetLineIntersection(A, B - A, C, D - C);</span><br><span class="line">            <span class="keyword">if</span> (OnSegment(ip, C, D)) newpoly.push_back(ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newpoly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 半平面交</span></span><br><span class="line"><span class="comment"> * @param[in]  L  直线集</span></span><br><span class="line"><span class="comment"> * @return 多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; HalfplaneIntersection(<span class="built_in">vector</span>&lt;Line&gt; L) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = L.size();</span><br><span class="line">    sort(L.begin(), L.end());</span><br><span class="line">    <span class="keyword">int</span> first, last;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; p(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Line&gt;  q(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; ans;</span><br><span class="line">    q[first = last = <span class="number">0</span>] = L[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; !OnLeft(L[i], p[last - <span class="number">1</span>])) last--;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; !OnLeft(L[i], p[first]))   first++;</span><br><span class="line">        q[++last] = L[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(Cross(q[last].v, q[last - <span class="number">1</span>].v)) &lt; eps) &#123;</span><br><span class="line">            last--;</span><br><span class="line">            <span class="keyword">if</span> (OnLeft(q[last], L[i].p)) q[last] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first &lt; last) p[last - <span class="number">1</span>] = GetLineIntersection(q[last - <span class="number">1</span>], q[last]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last &amp;&amp; !OnLeft(q[first], p[last - <span class="number">1</span>])) last--;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt;= <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    p[last] = GetLineIntersection(q[last], q[first]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) ans.push_back(p[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[<blockquote>
<p>本博客于 <code>2019.1.9</code> 首次开通<br>于 <code>2019.3.10</code> 更新至Hexo</p>
</blockquote>
<blockquote>
<p>本博客主要记载一些经验和算法模板(<code>C++</code>)</p>
<div style="text-align: right">于<code>2019.3.10</code></div>
</blockquote>
<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343" target="_blank" rel="noopener">鹤翔万里</a>的个人博客<br>现在还是一名$JL$的$OIer$,这个博客目前主要堆放了我学习$OI$算法时的笔记和一些题解<br>还可能有一些乱七八糟的文章(比如游记,做视频的经验之类的)‍ _(:3」∠)_<br>总之,非常感谢您能够来到这里,一起加油‍吧(〜￣△￣)〜</p>
<div style="text-align: right">于<code>2020.4.27</code></div></blockquote>
]]></content>
  </entry>
  <entry>
    <title>C++算法(OI)</title>
    <url>/algorithms/index.html</url>
    <content><![CDATA[<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p><a href="/2019/01/10/Cpp算法-DFS">深度优先搜索</a><br><a href="/2019/01/10/Cpp算法-BFS">广度优先搜索</a><br><a href="/2019/01/10/Cpp算法-动态规划">动态规划</a>&emsp;<a href="/2019/01/10/Cpp算法-背包问题">背包问题</a></p>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p><a href="/2019/01/10/Cpp算法-数论-线性筛素数">欧拉线性筛</a><br><a href="/2019/01/10/Cpp算法-大整数类">大整数类</a></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="/2019/01/10/Cpp算法-堆">堆</a><br><a href="/2019/01/10/Cpp算法-并查集">并查集</a><br><a href="/2019/01/10/Cpp算法-STL标准库">标准模板库STL</a><br><a href="/2019/01/10/Cpp算法-树状数组">树状数组</a></p>
<h2 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h2><p><a href="/2019/01/10/Cpp算法-字符串算法-字符串哈希">字符串哈希</a><br><a href="/2019/01/10/Cpp算法-字符串算法-哈希表">哈希表</a><br><a href="/2019/01/10/Cpp算法-字符串算法-KMP">KMP算法</a></p>
<h2 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h2><h3 id="链式前向星存储图"><a href="#链式前向星存储图" class="headerlink" title="链式前向星存储图"></a><a href="/2019/01/10/Cpp算法-图论-链式前向星">链式前向星存储图</a></h3><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p><a href="/2019/01/10/Cpp算法-图论-欧拉回路">欧拉回路</a></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><a href="/2019/01/10/Cpp算法-图论-Prim">Prim</a><br><a href="/2019/01/10/Cpp算法-图论-Kruskal">Kruskal</a></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><a href="/2019/01/10/Cpp算法-图论-Dijkstra">Dijkstra</a><br><a href="/2019/01/10/Cpp算法-图论-SPFA">SPFA</a><br><a href="/2019/01/10/Cpp算法-图论-Floyd">Floyd</a></p>
]]></content>
  </entry>
  <entry>
    <title>算法模板题目整理</title>
    <url>/Template-Problem/index.html</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">题目(附带超链接)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">堆</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3378" target="_blank" rel="noopener">Luogu P3378 堆</a></td>
</tr>
<tr>
<td style="text-align:left">单调栈</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2866" target="_blank" rel="noopener">Luogu P2866 糟糕的一天(USACO 06Nov)</a></td>
</tr>
<tr>
<td style="text-align:left">单调队列</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1440" target="_blank" rel="noopener">Luogu P1440 求m区间内的最小值</a></td>
</tr>
<tr>
<td style="text-align:left">前缀和</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3353" target="_blank" rel="noopener">Luogu P3353 在你窗外闪耀的星星</a></td>
</tr>
<tr>
<td style="text-align:left">二维前缀和</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2280" target="_blank" rel="noopener">Luogu P2280 [HNOI2003]激光炸弹</a></td>
</tr>
<tr>
<td style="text-align:left">差分数组</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1083" target="_blank" rel="noopener">Luogu P1083 借教室</a></td>
</tr>
<tr>
<td style="text-align:left">左偏树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3377" target="_blank" rel="noopener">Luogu P3377 左偏树(可并堆)</a></td>
</tr>
<tr>
<td style="text-align:left">并查集</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3367" target="_blank" rel="noopener">Luogu P3367 并查集</a></td>
</tr>
<tr>
<td style="text-align:left">带权并查集</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1196" target="_blank" rel="noopener">Luogu P1196 [NOI2002]银河英雄传说</a></td>
</tr>
<tr>
<td style="text-align:left">ST表</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">Luogu P3865 ST表</a></td>
</tr>
<tr>
<td style="text-align:left">线段树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3372" target="_blank" rel="noopener">Luogu P3372 线段树1</a></td>
</tr>
<tr>
<td style="text-align:left">树状数组</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3374" target="_blank" rel="noopener">Luogu P3374 树状数组1</a></td>
</tr>
<tr>
<td style="text-align:left">平衡树区间操作</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">Luogu P3391 文艺平衡树</a></td>
</tr>
<tr>
<td style="text-align:left">Treap Splay fhqTreap</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3369" target="_blank" rel="noopener">Luogu P3369 普通平衡树</a></td>
</tr>
<tr>
<td style="text-align:left">树链剖分</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">Luogu P3384 树链剖分</a></td>
</tr>
<tr>
<td style="text-align:left">Link-Cut Tree</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3690" target="_blank" rel="noopener">Luogu P3690 Link Cut Tree(动态树)</a></td>
</tr>
<tr>
<td style="text-align:left">树套树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3380" target="_blank" rel="noopener">Luogu P3380 二逼平衡树(树套树)</a></td>
</tr>
<tr>
<td style="text-align:left">二维树状数组</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4514" target="_blank" rel="noopener">Luogu P4514 上帝造题的七分钟</a></td>
</tr>
<tr>
<td style="text-align:left">二维线段树</td>
<td style="text-align:left"><a href="http://poj.org/problem?id=2029" target="_blank" rel="noopener">POJ2029 Get Many Persimmon Trees</a></td>
</tr>
<tr>
<td style="text-align:left">权值线段树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1908" target="_blank" rel="noopener">Luogu P1908 逆序对</a></td>
</tr>
<tr>
<td style="text-align:left">可持久化线段树(主席树)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3834" target="_blank" rel="noopener">Luogu P3834 可持久化线段树</a></td>
</tr>
<tr>
<td style="text-align:left">可持久化并查集</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3402" target="_blank" rel="noopener">Luogu P3402 可持久化并查集</a></td>
</tr>
<tr>
<td style="text-align:left">可持久化平衡树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3835" target="_blank" rel="noopener">Luogu P3835 可持久化平衡树</a></td>
</tr>
<tr>
<td style="text-align:left">Kruskal重构树</td>
<td style="text-align:left"><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3732" target="_blank" rel="noopener">BZOJ3732 Network</a></td>
</tr>
<tr>
<td style="text-align:left">莫队</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2709" target="_blank" rel="noopener">Luogu P2709 小B的询问</a></td>
</tr>
<tr>
<td style="text-align:left">带修莫队</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3939" target="_blank" rel="noopener">Luogu P3939 数颜色</a></td>
</tr>
</tbody>
</table>
<h2 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h2><table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">题目(附带超链接)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">KMP算法</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3375" target="_blank" rel="noopener">Luogu P3375 KMP字符串匹配</a></td>
</tr>
<tr>
<td style="text-align:left">字符串哈希</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3370" target="_blank" rel="noopener">Luogu P3370 字符串哈希</a></td>
</tr>
<tr>
<td style="text-align:left">哈希表</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4305" target="_blank" rel="noopener">Luogu P4305 [JLOI2011]不重复数字</a></td>
</tr>
<tr>
<td style="text-align:left">Trie树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2580" target="_blank" rel="noopener">Luogu P2580 于是他错误的点名开始了</a></td>
</tr>
<tr>
<td style="text-align:left">AC自动机</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3808" target="_blank" rel="noopener">Luogu P3808 AC自动机(简单版)</a></td>
</tr>
<tr>
<td style="text-align:left">最小表示法</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1368" target="_blank" rel="noopener">Luogu P1368 工艺</a></td>
</tr>
<tr>
<td style="text-align:left">manacher</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3805" target="_blank" rel="noopener">Luogu P3805 manacher算法</a></td>
</tr>
<tr>
<td style="text-align:left">回文自动机</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3649" target="_blank" rel="noopener">Luogu P3649 [APIO2014]回文串</a></td>
</tr>
<tr>
<td style="text-align:left">后缀数组</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3809" target="_blank" rel="noopener">Luogu P3809 后缀排序</a></td>
</tr>
<tr>
<td style="text-align:left">后缀自动机</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3804" target="_blank" rel="noopener">Luogu P3804 后缀自动机</a></td>
</tr>
</tbody>
</table>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">题目(附带超链接)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">快速幂</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1226" target="_blank" rel="noopener">Luogu P1226 快速幂/取余运算</a></td>
</tr>
<tr>
<td style="text-align:left">线性筛素数</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3383" target="_blank" rel="noopener">Luogu P3383 线性筛素数</a></td>
</tr>
<tr>
<td style="text-align:left">线性筛欧拉函数</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/UVA12995" target="_blank" rel="noopener">UVa12995 Farey Sequence</a></td>
</tr>
<tr>
<td style="text-align:left">乘法逆元</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1082" target="_blank" rel="noopener">Luogu P1082 同余方程</a></td>
</tr>
<tr>
<td style="text-align:left">线性求逆元</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3811" target="_blank" rel="noopener">Luogu P3811 乘法逆元</a></td>
</tr>
<tr>
<td style="text-align:left">扩展欧几里得算法</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1516" target="_blank" rel="noopener">Luogu P1516 青蛙的约会</a></td>
</tr>
<tr>
<td style="text-align:left">(扩展)欧拉定理</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P5091" target="_blank" rel="noopener">Luogu P5091 欧拉定理</a></td>
</tr>
<tr>
<td style="text-align:left">裴蜀定理</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4549" target="_blank" rel="noopener">Luogu P4549 裴蜀定理</a></td>
</tr>
<tr>
<td style="text-align:left">威尔逊定理</td>
<td style="text-align:left"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5391" target="_blank" rel="noopener">HDU5391 Zball in China Town</a></td>
</tr>
<tr>
<td style="text-align:left">费马小定理</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2842" target="_blank" rel="noopener">Luogu P2842 LJJ算数</a></td>
</tr>
<tr>
<td style="text-align:left">中国剩余定理</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/UVA756" target="_blank" rel="noopener">UVa756 Biorhythms</a></td>
</tr>
<tr>
<td style="text-align:left">扩展中国剩余定理</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4777" target="_blank" rel="noopener">Luogu P4777 扩展中国剩余定理</a></td>
</tr>
<tr>
<td style="text-align:left">整除分块</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2261" target="_blank" rel="noopener">Luogu P2261 [CQOI2007]余数求和</a></td>
</tr>
<tr>
<td style="text-align:left">莫比乌斯反演</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2257" target="_blank" rel="noopener">Luogu P2257 YY的GCD</a></td>
</tr>
<tr>
<td style="text-align:left">杜教筛</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4213" target="_blank" rel="noopener">Luogu P4213 杜教筛</a></td>
</tr>
<tr>
<td style="text-align:left">离散对数(BSGS)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3846" target="_blank" rel="noopener">Luogu P3846 [TJOI2007]可爱的质数</a></td>
</tr>
<tr>
<td style="text-align:left">扩展BSGS</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4195" target="_blank" rel="noopener">Luogu P4195 exBSGS</a></td>
</tr>
<tr>
<td style="text-align:left">秦九韶算法</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2312" target="_blank" rel="noopener">Luogu P2312 解方程</a></td>
</tr>
<tr>
<td style="text-align:left">拉格朗日差值</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4781" target="_blank" rel="noopener">Luogu P4781 拉格朗日差值</a></td>
</tr>
<tr>
<td style="text-align:left">康托展开</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4593" target="_blank" rel="noopener">Luogu P4593 [TJOI2018]教科书般的亵渎</a></td>
</tr>
<tr>
<td style="text-align:left">卢卡斯定理</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3807" target="_blank" rel="noopener">Luogu P3807 卢卡斯定理</a></td>
</tr>
<tr>
<td style="text-align:left">扩展卢卡斯</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4720" target="_blank" rel="noopener">Luogu P4720 扩展卢卡斯</a></td>
</tr>
<tr>
<td style="text-align:left">杨辉三角</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2822" target="_blank" rel="noopener">Luogu P2822 组合数问题</a></td>
</tr>
<tr>
<td style="text-align:left">斐波那契数列</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1962" target="_blank" rel="noopener">Luogu P1962 斐波那契数列</a></td>
</tr>
<tr>
<td style="text-align:left">斯特林数</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1655" target="_blank" rel="noopener">Luogu P1655 小朋友的球</a></td>
</tr>
<tr>
<td style="text-align:left">卡特兰数</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1375" target="_blank" rel="noopener">Luogu P1375 小猫</a></td>
</tr>
<tr>
<td style="text-align:left">Prufer编码与Cayley公式</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4430" target="_blank" rel="noopener">Luogu P4430 小猴打架</a></td>
</tr>
<tr>
<td style="text-align:left">Matrix-Tree定理</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/SP104" target="_blank" rel="noopener">SP104 HIGH-Highways</a></td>
</tr>
<tr>
<td style="text-align:left">高斯消元法</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3389" target="_blank" rel="noopener">Luogu P3389 高斯消元法</a></td>
</tr>
<tr>
<td style="text-align:left">矩阵快速幂</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1349" target="_blank" rel="noopener">Luogu P1349 广义斐波那契数列</a></td>
</tr>
<tr>
<td style="text-align:left">矩阵求逆</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4783" target="_blank" rel="noopener">Luogu P4783 矩阵求逆</a></td>
</tr>
<tr>
<td style="text-align:left">快速沃尔什变换</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4717" target="_blank" rel="noopener">Luogu P4717 快速沃尔什变换</a></td>
</tr>
<tr>
<td style="text-align:left">线性基</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3812" target="_blank" rel="noopener">Luogu P3812 线性基</a></td>
</tr>
<tr>
<td style="text-align:left">01字典树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4551" target="_blank" rel="noopener">Luogu P4551 最长异或路径</a></td>
</tr>
<tr>
<td style="text-align:left">可持久化01字典树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4735" target="_blank" rel="noopener">Luogu P4735 最大异或和</a></td>
</tr>
</tbody>
</table>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">题目(附带超链接)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">欧拉回路</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1341" target="_blank" rel="noopener">Luogu P1341 无序字母对</a></td>
</tr>
<tr>
<td style="text-align:left">拓扑排序</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2419" target="_blank" rel="noopener">Luogu P2419 牛大赛(USACO 08Jan)</a></td>
</tr>
<tr>
<td style="text-align:left">单源最短路(Dijkstra,SPFA)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3371" target="_blank" rel="noopener">Luogu P3371 单源最短路径(弱化版)</a></td>
</tr>
<tr>
<td style="text-align:left">单源最短路(Dijkstra+堆)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4779" target="_blank" rel="noopener">Luogu P4779 单源最短路径(标准版)</a></td>
</tr>
<tr>
<td style="text-align:left">点对最短路(Floyd)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1522" target="_blank" rel="noopener">Luogu P1522 牛的旅行(USACO 2.4)</a></td>
</tr>
<tr>
<td style="text-align:left">次短路</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2865" target="_blank" rel="noopener">Luogu P2865 路障(USACO 06Nov)</a></td>
</tr>
<tr>
<td style="text-align:left">k短路</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2483" target="_blank" rel="noopener">Luogu P2483 k短路(SDOI2010 魔法猪学院)</a></td>
</tr>
<tr>
<td style="text-align:left">最小生成树(Kruskal,Prim)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3366" target="_blank" rel="noopener">Luogu P3366 最小生成树</a></td>
</tr>
<tr>
<td style="text-align:left">次小生成树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4180" target="_blank" rel="noopener">Luogu P4180 严格次小生成树</a></td>
</tr>
<tr>
<td style="text-align:left">最小树形图</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4716" target="_blank" rel="noopener">Luogu P4716 最小树形图</a></td>
</tr>
<tr>
<td style="text-align:left">差分约束</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P1993" target="_blank" rel="noopener">Luogu P1993 小K的农场</a></td>
</tr>
<tr>
<td style="text-align:left">强连通分量(Tarjan)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2341" target="_blank" rel="noopener">Luogu P2341 受欢迎的牛</a></td>
</tr>
<tr>
<td style="text-align:left">2-SAT</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3007" target="_blank" rel="noopener">Luogu P3007 大陆会议</a></td>
</tr>
<tr>
<td style="text-align:left">负环(SPFA)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3385" target="_blank" rel="noopener">Luogu P3385 负环</a></td>
</tr>
<tr>
<td style="text-align:left">最大流(EK,Dinic,ISAP)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3376" target="_blank" rel="noopener">Luogu P3376 网络最大流</a></td>
</tr>
<tr>
<td style="text-align:left">最大流(预流推进)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4722" target="_blank" rel="noopener">Luogu P4722 最大流加强版/预流推进</a></td>
</tr>
<tr>
<td style="text-align:left">费用流</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3381" target="_blank" rel="noopener">Luogu P3381 最小费用最大流</a></td>
</tr>
<tr>
<td style="text-align:left">有上下界的网络流</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4843" target="_blank" rel="noopener">Luogu P4843 清理雪道</a></td>
</tr>
<tr>
<td style="text-align:left">二分图匹配(匈牙利)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3386" target="_blank" rel="noopener">Luogu P3386 二分图匹配</a></td>
</tr>
<tr>
<td style="text-align:left">点分治</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3806" target="_blank" rel="noopener">Luogu P3806 点分治</a></td>
</tr>
<tr>
<td style="text-align:left">平面图转对偶图</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4001" target="_blank" rel="noopener">Luogu P4001 狼抓兔子</a></td>
</tr>
<tr>
<td style="text-align:left">最小割树</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3329" target="_blank" rel="noopener">Luogu P3329 最小割</a></td>
</tr>
<tr>
<td style="text-align:left">虚边</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P3393" target="_blank" rel="noopener">Luogu P3393 逃离僵尸岛</a></td>
</tr>
<tr>
<td style="text-align:left">线段树优化建边</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/CF786B" target="_blank" rel="noopener">CF786B Legacy</a></td>
</tr>
<tr>
<td style="text-align:left">分层图</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2939" target="_blank" rel="noopener">Luogu P2939 改造路(USACO 09Feb)</a></td>
</tr>
<tr>
<td style="text-align:left">同余类BFS</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2662" target="_blank" rel="noopener">Luogu P2662 牛场围栏</a></td>
</tr>
</tbody>
</table>
<h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">题目(附带超链接)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">综合有关圆的计算</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/UVA12304" target="_blank" rel="noopener">UVa12304 2D Geometry 110 in 1!</a></td>
</tr>
<tr>
<td style="text-align:left">二维凸包</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P2742" target="_blank" rel="noopener">Luogu P2742 二维凸包/圈奶牛(USACO 5.1)</a></td>
</tr>
<tr>
<td style="text-align:left">旋转卡壳</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/UVA1453" target="_blank" rel="noopener">UVa1453 Squares</a></td>
</tr>
<tr>
<td style="text-align:left">半平面交</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/UVA1304" target="_blank" rel="noopener">UVa1304 Art Gallery</a></td>
</tr>
<tr>
<td style="text-align:left">平面区域(PSLG)</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/UVA1318" target="_blank" rel="noopener">UVa1318 Monstar Trap</a></td>
</tr>
<tr>
<td style="text-align:left">三维凸包</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4724" target="_blank" rel="noopener">Luogu P4724 三维凸包</a></td>
</tr>
<tr>
<td style="text-align:left">闵可夫斯基和</td>
<td style="text-align:left"><a href="https://www.luogu.org/problemnew/show/P4724" target="_blank" rel="noopener">Luogu P4557 [JSOI2018]战争</a></td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>恭喜你发现彩蛋</title>
    <url>/p/031218.html</url>
    <content><![CDATA[<p><code>2003-12-18</code>是我的生日哦</p>
<p>在下面留个言吧!</p>
]]></content>
  </entry>
  <entry>
    <title>恭喜你发现彩蛋</title>
    <url>/p/171431343.html</url>
    <content><![CDATA[<p><code>171431343</code>是我的B站uid哦</p>
<p>在下面留个言吧!</p>
]]></content>
  </entry>
  <entry>
    <title>恭喜你发现彩蛋</title>
    <url>/p/20031218.html</url>
    <content><![CDATA[<p><code>2003-12-18</code>是我的生日哦</p>
<p>在下面留个言吧!</p>
]]></content>
  </entry>
</search>
