---
title: 「网络流24题」餐巾计划问题-题解
mathjax: true
toc: true
tags:
  - Cpp
  - 题解
  - NOIp
  - 网络流
  - 费用流
categories:
  - 题解
  - 网络流24题
abbrlink: 93562de2
date: 2020-04-14 10:56:49
---

题目传送门: [「Luogu P1251」餐巾计划问题](https://www.luogu.com.cn/problem/P1251)

<!--more-->

### 题目大意
在$N$天里,第$i$天需要$r_i$个餐巾
1. 可以购买餐巾,每张$p$元
2. 可以将旧送快洗,$m$天,费用$f$元
3. 可以将旧送慢洗,$n$天,费用$s$元
4. 每天结束,可以送快洗,慢洗,保存

设计最小花费

### 题解
将每天拆成2个点(早晚),新建源点汇点(源点表示获得,汇点表示使用)
1. 每天早上的点,向汇点连 __流量为$r_i$,费用为$0$__ 的边,表示当日需要使用
2. 源点向每天晚上的点连 __流量为$r_i$,费用为$0$__ 的边,每天晚上获得多少旧餐巾
3. 源点向每天早上的点连 __流量为$inf$,费用为$p$__ 的边,表示购买
4. 每天晚上向$+m$天的早上连 __流量为$inf$,费用为$f$__ 的边,表示快洗
5. 每天晚上向$+n$天的早上连 __流量为$inf$,费用为$s$__ 的边,表示快洗
6. 每天晚上向第二天晚上连 __流量为$inf$,费用为$0$__ 的边,表示保留

跑最小费用最大流

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

inline int read() {
    int x = 0; int f = 1; char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
    while (isdigit(ch))  {x = x * 10 + ch - 48; ch = getchar();}
    return x * f;
}

const int maxn = 4010;
const int inf  = 0x3f3f3f3f;

int n, m, s, t, ansflow, r[maxn];
int vis[maxn], d[maxn], p[maxn], a[maxn];
long long anscost;

struct Edge {
	int from, to, cap, flow, cost;
	Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}
};
vector<Edge> edges;
vector<int> G[maxn];
void add(int u, int v, int c, int w) {
	edges.push_back(Edge(u, v, c, 0, w));
	edges.push_back(Edge(v, u, 0, 0,-w));
	int mm = edges.size();
	G[u].push_back(mm - 2);
	G[v].push_back(mm - 1);
}

bool BellmanFord(int& flow, long long& cost) {
	for (int i = 1; i <= n; ++i) d[i] = inf;
	memset(vis, 0, sizeof(vis));
	d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf;
	queue<int> Q;
	Q.push(s);
	while (!Q.empty()) {
		int x = Q.front(); Q.pop();
		vis[x] = 0;
		for (int i = 0; i < G[x].size(); ++i) {
			Edge& e = edges[G[x][i]];
			if (e.cap > e.flow && d[e.to] > d[x] + e.cost) {
				d[e.to] = d[x] + e.cost;
				p[e.to] = G[x][i];
				a[e.to] = min(a[x], e.cap - e.flow);
				if (!vis[e.to]) {
					Q.push(e.to);
					vis[e.to] = 1;
				}
			}
		}
	}
	if (d[t] == inf) return false;
	flow += a[t];
	cost += (long long)d[t] * (long long)a[t];
	for (int u = t; u != s; u = edges[p[u]].from) {
		edges[p[u]].flow += a[t];
		edges[p[u] ^ 1].flow -= a[t];
	}
	return true;
}

int MinCostMaxFlow(long long& cost) {
	int flow = 0; cost = 0;
	while (BellmanFord(flow, cost));
	return flow;
}

int main() {
    int N = read(); s = 0; t = 2 * N + 1;
    n = t + 1;
    for (int i = 1; i <= N; ++i) {
        r[i] = read();
        add(s, i + N, r[i], 0);
        add(i, t, r[i], 0);
    }
    int pr = read(), t1 = read(), c1 = read(), t2 = read(), c2 = read();
    for (int i = 1; i <= N; ++i) {
        if (i + 1 <= N) add(i + N, i + N + 1, inf, 0);
        if (i + t1 <= N) add(i + N, i + t1, inf, c1);
        if (i + t2 <= N) add(i + N, i + t2, inf, c2);
        add(s, i, inf, pr);
    }
    MinCostMaxFlow(anscost);
    printf("%lld\n", anscost);
    return 0;
}
```
