---
title: 「网络流24题」孤岛营救问题-题解
mathjax: true
toc: true
tags:
  - Cpp
  - 题解
  - NOIp
  - 最短路
  - bfs
  - 状态压缩
categories:
  - 题解
  - 网络流24题
abbrlink: 5c532c45
date: 2020-04-22 08:45:49
---

题目传送门: [「Luogu P4011」孤岛营救问题](https://www.luogu.com.cn/problem/P4011)

<!--more-->

### 题目大意
起点为$(1,1)$,终点为$(n,m)$
有些格子上有若干个钥匙，两个格子之间可能有一堵墙或者一扇可以用对应钥匙打开的门
每次移动需要$1$个单位时间，其他动作不需要时间

求最少需要多少时间能从起点到达终点。

### 题解
对拥有的钥匙状态进行压缩
从起点到终点跑bfs即可


### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
    int x = 0; int f = 1; char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
    while (isdigit(ch))  {x = x * 10 + ch - 48; ch = getchar();}
    return x * f;
}

const int maxn = 20;
const int go[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

int n, m, p, k;
int cnt[maxn][maxn], key[maxn][maxn][maxn];
bool vis[maxn][maxn][1 << 15];
int edge[maxn][maxn][maxn][maxn];

struct Node {
    int x, y;
    int keys, times;
    Node(int x, int y, int k, int t): x(x), y(y), keys(k), times(t) {}
};

queue<Node> q;
int bfs() {
    int skey = 0;
    for (int i = 1; i <= cnt[1][1]; ++i) skey |= (1 << (key[1][1][i] - 1));
    q.push(Node(1, 1, skey, 0)); vis[1][1][skey] = true;
    while (!q.empty()) {
        Node u = q.front(); q.pop();
        if (u.x == n && u.y == m) return u.times;
        for (int k = 0; k < 4; ++k) {
            int vx = u.x + go[k][0], vy = u.y + go[k][1];
            if (vx < 1 || vx > n || vy < 1 || vy > m) continue;
            int e = edge[u.x][u.y][vx][vy];
            if (e < 0 || (e > 0 && !(1 << (e - 1) & u.keys))) continue;
            int vkeys = 0;
            for (int i = 1; i <= cnt[vx][vy]; ++i) vkeys |= (1 << (key[vx][vy][i] - 1));
            int nxtkeys = u.keys | vkeys;
            if (vis[vx][vy][nxtkeys]) continue;
            q.push(Node(vx, vy, nxtkeys, u.times + 1));
            vis[vx][vy][nxtkeys] = true;
        }
    }
    return -1;
}


int main() {
    n = read(); m = read(); p = read(); k = read();
    for (int i = 1; i <= k; ++i) {
        int x1 = read(), y1 = read(), x2 = read(), y2 = read();
        int g = read();
        edge[x1][y1][x2][y2] = ((g == 0) ? -1 : g);
        edge[x2][y2][x1][y1] = edge[x1][y1][x2][y2];
    }
    int s = read();
    for (int i = 1; i <= s; ++i) {
        int x1 = read(), y1 = read(), q = read();
        key[x1][y1][++cnt[x1][y1]] = q;
    }
    int ans = bfs();
    printf("%d\n", ans);
    return 0;
}
```