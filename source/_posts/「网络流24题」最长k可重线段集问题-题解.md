---
title: 「网络流24题」最长k可重线段集问题-题解
mathjax: true
toc: true
tags:
  - Cpp
  - 题解
  - NOIp
  - 网络流
  - 费用流
categories:
  - 题解
  - 网络流24题
abbrlink: f48af49a
date: 2020-04-21 10:35:30
---

题目传送门: [「Luogu P3357」最长k可重线段集问题](https://www.luogu.com.cn/problem/P3357)

<!--more-->

### 题目大意
给定一个开线段的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开线段,组成集合$\mathbf{S}$
使对于任何一条直线$x=p$,满足$\mathbf{S}$中与$x=p$相交的线段数不超过$k$,且$\mathbf{S}$中开线段总长度最大

求最大的长度

### 题解
和[「Luogu P3358」最长k可重区间集问题](https://www.luogu.com.cn/problem/P3358)类似
仅修改一下区间的输入部分即可

将每条线段映射到x轴上,发现可能不对,因为可能会存在垂直于x轴的线段,像P3358一样建图会省略掉这条线段

所以要将每个点扩大一倍,将左右端点x坐标相同的区间$(x, x)$更改为$(2x, 2x+1)$,使得不存在与x轴垂直的线段
如果左右端点x坐标不相同,则将$(x_1, x_2)$更改为$(2x_1+1, 2x_2)$

大概就是这么个道理:
![](/f48af49a/NF24P3357.png)

剩下的做法和[P3358](https://www.luogu.com.cn/problem/P3358)一样,[P3358题解](https://tony031218.github.io/2020/04/21/%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E6%9C%80%E9%95%BFk%E5%8F%AF%E9%87%8D%E5%8C%BA%E9%97%B4%E9%9B%86%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/)

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
    int x = 0; int f = 1; char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
    while (isdigit(ch))  {x = x * 10 + ch - 48; ch = getchar();}
    return x * f;
}

const int maxn = 2010;
const int inf  = 0x3f3f3f3f;
const int ninf = 0xc0c0c0c0;

int n, m, s, t, ansflow;
int vis[maxn], d[maxn], p[maxn], a[maxn];
long long anscost;

struct Edge {
	int from, to, cap, flow, cost;
	Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}
};
vector<Edge> edges;
vector<int> G[maxn];
void add(int u, int v, int c, int w) {
	edges.push_back(Edge(u, v, c, 0, w));
	edges.push_back(Edge(v, u, 0, 0,-w));
	int mm = edges.size();
	G[u].push_back(mm - 2);
	G[v].push_back(mm - 1);
}

bool BellmanFord(int& flow, long long& cost) {
    memset(d, 0xc0, sizeof(d));
	memset(vis, 0, sizeof(vis));
	d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf;
	queue<int> Q;
	Q.push(s);
	while (!Q.empty()) {
		int x = Q.front(); Q.pop();
		vis[x] = 0;
		for (int i = 0; i < G[x].size(); ++i) {
			Edge& e = edges[G[x][i]];
			if (e.cap > e.flow && d[e.to] < d[x] + e.cost) {
				d[e.to] = d[x] + e.cost;
				p[e.to] = G[x][i];
				a[e.to] = min(a[x], e.cap - e.flow);
				if (!vis[e.to]) {
					Q.push(e.to);
					vis[e.to] = 1;
				}
			}
		}
	}
	if (d[t] == ninf) return false;
	flow += a[t];
	cost += (long long)d[t] * (long long)a[t];
	for (int u = t; u != s; u = edges[p[u]].from) {
		edges[p[u]].flow += a[t];
		edges[p[u] ^ 1].flow -= a[t];
	}
	return true;
}

int MaxCostMaxFlow(long long& cost) {
	int flow = 0; cost = 0;
	while (BellmanFord(flow, cost));
	return flow;
}

struct Interval {
    int l, r, len;
}inter[510];
int nums[1020], old[1020];

int length(int a, int b, int c, int d) {
    return (int)sqrt((long long)(a - c) * (a - c) + (long long)(b - d) * (b - d));
}

int main() {
    int n_ = read(), k = read();
    for (int i = 1; i <= n_; ++i) {
        int a = read(), b = read(), c = read(), d = read();
        inter[i].len = length(a, b, c, d);
        inter[i].l = a * 2;
        inter[i].r = c * 2;
        if (a == c) inter[i].r += 1;
        else inter[i].l += 1;
        nums[i * 2 - 1] = inter[i].l;
        nums[i * 2] = inter[i].r;
    }
    
    for (int i = 1; i <= n_ * 2; ++i) old[i] = nums[i];
    sort(old + 1, old + 1 + n_ * 2);
    int len = unique(old + 1, old + 1 + n_ * 2) - old - 1;
    for (int i = 1; i <= n_ * 2; ++i) nums[i] = lower_bound(old + 1, old + 1 + len, nums[i]) - old;
    
    for (int i = 1; i <= n_; ++i) {
        inter[i].l = nums[i * 2 - 1];
        inter[i].r = nums[i * 2];
    }
    s = 0; n = len + 2; t = n - 1;
    add(s, 1, k, 0);
    for (int i = 1; i <= len; ++i) {
        add(i, i + 1, inf, 0);
    }
    for (int i = 1; i <= n_; ++i) {
        add(inter[i].l, inter[i].r, 1, inter[i].len);
    }
    ansflow = MaxCostMaxFlow(anscost);
    printf("%d\n", anscost);
    return 0;
}
```